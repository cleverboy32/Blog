"use strict";(self.webpackChunkcboy_blog=self.webpackChunkcboy_blog||[]).push([[990],{990:function(e,n,t){t.r(n),t.d(n,{default:function(){return i}});var o=t(762);const r={class:"component-module"},c={};var i=(0,t(314).A)(c,[["render",function(e,n){return(0,o.uX)(),(0,o.CE)("div",r,n[0]||(n[0]=[(0,o.Fv)('<p>当我们要完成一个应用的时候，会根据对应的功能划分为许多不同的模块，就像一个论坛，有发帖的模块，评论的模块，js 中的模块也正是如此，一个具体功能的代码抽成一个文件，当你做一个东西的时候需要用到这个功能的时，可以直接使用这个文件，实现功能的分离，并能在多个需要的地方使用。就像是螺丝钉、螺丝帽、垫片一样的，通过组合使用实现出你的产品。</p><p>通过直白的描述，我们可以知道，模块化的好处就是，抽离代码，重复使用，如现在很直观的代表 npm 包。</p><p>那么模块化到底是怎么实现的呢？</p><p>先来了解一下历史，以前的 html 不知道大家还记不记的， 一个html 页面引入了多个 js 文件.</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;So UI - A Component Library for Vue.js.&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;d.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;e.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>如上，引入了 a/b/c/d/e 五个文件，这五个文件如果相互之间有依赖，还要注意引入的顺序，并且还需要注意它们里面的变量名，若是重复利用到其他的项目，其他项目也需要注意到以上两点问题。为了解决这一问题，就有了模块化的规范。</p><p>模块化的规范，有 <a href="http://javascript.ruanyifeng.com/nodejs/module.html">CMD</a> 和 <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">AMD</a></p><p>CMD (Common Module Definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。它主要特点是：对于依赖的模块是延迟执行，依赖可以就近书写，等到需要用这个依赖的时候再引入这个依赖，应用有sea.js.</p><p>AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js</p><p>尽情的猜测，require.js 是怎么弄的呢？ 它需要依次的加载模块然后去进行相应的操作，加载模块就是要引入这个文件，那么这里也还是通过动态加载 script 的方法，并通过 onload 去执行后面的回调了。</p><p>我们知道现如今 es6 已经支持模块化了，它分为 export 和 import 两个命令。 export 导出你定义的模块变量， import 引入一个模块变量。</p><pre><code>export { \n \tone, \n \ttwo\n }\n export default three;\n</code></pre><p>对应的引入代码</p><pre><code>import  { one, two }  three from &#39;a.js&#39;\n</code></pre><p>可以看到 export 可以导出一个默认的变量，也可以导出变量对象，这里引入的时候名字不要写错了。 那么 es6 的模块化通过babel 转码其实就是 umd 模块规范， 它是一个兼容 cmd 和 amd 的模块化规范, 同时还支持老式的“全局”变量规范</p><pre><code>(function (root, factory) {\n    if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {\n        // AMD\n        define([&#39;jquery&#39;], factory);\n    } else if (typeof exports === &#39;object&#39;) {\n        // Node, CommonJS之类的\n        module.exports = factory(require(&#39;jquery&#39;));\n    } else {\n        // 浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    方法\n    function myFunc(){};\n \n    //    暴露公共方法\n    return myFunc;\n}));\n</code></pre><p>那么浏览器是如何支持这种规范的呢？ 其实是实现了根据这种规范定制出来的功能。这里我们就按照 实现了 AMD 规范的 require.js 来讲一下实现代码。</p><p>AMD 定义一个模块的方法是 define(id?, dependencies?, factory)。</p><p>参考define 的方法代码</p><pre><code> define = function (name, deps, callback) {\n        var node, context;\n        \n        //Allow for anonymous modules\n        if (typeof name !== &#39;string&#39;) {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps &amp;&amp; isFunction(callback)) {\n            deps = [];\n            //移除注释\n            //查找 require 语句，收集依赖到 deps 里面\n            // but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, commentReplace)\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? [&#39;require&#39;] : [&#39;require&#39;, &#39;exports&#39;, &#39;module&#39;]).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute(&#39;data-requiremodule&#39;);\n                }\n                context = contexts[node.getAttribute(&#39;data-requirecontext&#39;)];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        if (context) {\n            context.defQueue.push([name, deps, callback]);\n            context.defQueueMap[name] = true;\n        } else {\n            globalDefQueue.push([name, deps, callback]);\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n    \n\treq.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n</code></pre><p>可以知道，这一段代码是解析定义是模块所需的依赖放置 context 的模块定义队列中。然后我们就要通过 req 去执行加载依赖，我们来看看 req 的定义。</p><pre><code>req = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) &amp;&amp; typeof deps !== &#39;string&#39;) {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config &amp;&amp; config.context) {\n            contextName = config.context;\n        }\n       \n        if (config) {\n            context.configure(config); // 完善配置\n        }\n\n        return context.require(deps, callback, errback); \n</code></pre><p>这里的代码把 依赖，回调， 错误处理和配置项都传进来了，进行了配置上的处理之后，我们可以看到最后再去根据配置加载。 我们再来看 context.require 方法</p><pre><code>makeRequire: function (relMap, options) {\n\t\toptions = options || {};\n\t\tfunction localRequire(deps, callback, errback) {\n\t\t\t.... 当前 require 的转换\n      \t \treturn localRequire;\n  \t\t }\n\t\tcompleteLoad: function (moduleName) {\n\t\t\t判断 context 的依赖队列，是继续加载还是执行回调\n\t\t}\n\t\t nameToUrl: function (moduleName, ext, skipExt) {\n\t\t \t根据模块名和配置得到加载的路径\n\t\t }\n\t\t load: function (id, url) {\n\t               req.load(context, id, url);\n\t      },\n\t      execCb: function (name, callback, args, exports) {\n\t                return callback.apply(exports, args);\n\t        },\n\t\tonScriptLoad: function (evt) {\n\t\t\t脚本加载完成后得到数据，执行 context.completeLoad(data.id);\n\t\t}\n\t\tonScriptError: function (evt) {\n\t\t\t加载错误执行错误处理\n\t\t}\n\t};\n   context.require = context.makeRequire();\n</code></pre><p>那我们知道其实就是围着这语法的解析，进行一系列的脚本加载，然后执行回调。</p>',25)]))}]])}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkwLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiNktBQWVBLE1BQU0sb0JDQ2ZDLEVBQVMsQ0FBQyxFQUtoQixPQUZpQyxFLE9BQUEsR0FBZ0JBLEVBQVEsQ0FBQyxDQUFDLFMsZ0NESmpEQyxFQUFBQSxFQUFBQSxJQXVNSixNQXZNSUMsRUF1TUpDLEVBQUEsS0FBQUEsRUFBQSxLQXZNTkMsRUFBQUEsRUFBQUEsSUFBQSxtOE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYm95LWJsb2cvLi4vLi4vYmxvZ3MvbWFya2Rvd24vbW9kdWxlLm1kIiwid2VicGFjazovL2Nib3ktYmxvZy8uLi8uLi9ibG9ncy9tYXJrZG93bi9tb2R1bGUubWQ/NmNlZCJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+PGRpdiBjbGFzcz1cImNvbXBvbmVudC1tb2R1bGVcIj48cD7lvZPmiJHku6zopoHlrozmiJDkuIDkuKrlupTnlKjnmoTml7blgJnvvIzkvJrmoLnmja7lr7nlupTnmoTlip/og73liJLliIbkuLrorrjlpJrkuI3lkIznmoTmqKHlnZfvvIzlsLHlg4/kuIDkuKrorrrlnZvvvIzmnInlj5HluJbnmoTmqKHlnZfvvIzor4TorrrnmoTmqKHlnZfvvIxqcyDkuK3nmoTmqKHlnZfkuZ/mraPmmK/lpoLmraTvvIzkuIDkuKrlhbfkvZPlip/og73nmoTku6PnoIHmir3miJDkuIDkuKrmlofku7bvvIzlvZPkvaDlgZrkuIDkuKrkuJzopb/nmoTml7blgJnpnIDopoHnlKjliLDov5nkuKrlip/og73nmoTml7bvvIzlj6/ku6Xnm7TmjqXkvb/nlKjov5nkuKrmlofku7bvvIzlrp7njrDlip/og73nmoTliIbnprvvvIzlubbog73lnKjlpJrkuKrpnIDopoHnmoTlnLDmlrnkvb/nlKjjgILlsLHlg4/mmK/onrrkuJ3pkonjgIHonrrkuJ3luL3jgIHlnqvniYfkuIDmoLfnmoTvvIzpgJrov4fnu4TlkIjkvb/nlKjlrp7njrDlh7rkvaDnmoTkuqflk4HjgII8L3A+XG48cD7pgJrov4fnm7Tnmb3nmoTmj4/ov7DvvIzmiJHku6zlj6/ku6Xnn6XpgZPvvIzmqKHlnZfljJbnmoTlpb3lpITlsLHmmK/vvIzmir3nprvku6PnoIHvvIzph43lpI3kvb/nlKjvvIzlpoLnjrDlnKjlvojnm7Top4LnmoTku6PooaggbnBtIOWMheOAgjwvcD5cbjxwPumCo+S5iOaooeWdl+WMluWIsOW6leaYr+aAjuS5iOWunueOsOeahOWRou+8nzwvcD5cbjxwPuWFiOadpeS6huino+S4gOS4i+WOhuWPsu+8jOS7peWJjeeahCBodG1sIOS4jeefpemBk+Wkp+Wutui/mOiusOS4jeiusOeahO+8jCDkuIDkuKpodG1sIOmhtemdouW8leWFpeS6huWkmuS4qiBqcyDmlofku7YuPC9wPlxuPHByZSB2LXByZT1cIlwiPjxjb2RlPiZsdDshRE9DVFlQRSBodG1sJmd0O1xuJmx0O2h0bWwgbGFuZz1cInpoLUNOXCImZ3Q7XG4mbHQ7aGVhZCZndDtcbiAgICAmbHQ7bWV0YSBjaGFyc2V0PVwiVVRGLThcIiZndDtcbiAgICAmbHQ7dGl0bGUmZ3Q7U28gVUkgLSBBIENvbXBvbmVudCBMaWJyYXJ5IGZvciBWdWUuanMuJmx0Oy90aXRsZSZndDtcbiZsdDsvaGVhZCZndDtcbiZsdDtib2R5Jmd0O1xuICAgICZsdDtkaXYgaWQ9XCJhcHBcIiZndDsmbHQ7L2RpdiZndDtcbiAgICAmbHQ7c2NyaXB0IHNyYz1cImEuanNcIiZndDsmbHQ7L3NjcmlwdCZndDtcbiAgICAmbHQ7c2NyaXB0IHNyYz1cImIuanNcIiZndDsmbHQ7L3NjcmlwdCZndDtcbiAgICAmbHQ7c2NyaXB0IHNyYz1cImMuanNcIiZndDsmbHQ7L3NjcmlwdCZndDtcbiAgICAmbHQ7c2NyaXB0IHNyYz1cImQuanNcIiZndDsmbHQ7L3NjcmlwdCZndDtcbiAgICAmbHQ7c2NyaXB0IHNyYz1cImUuanNcIiZndDsmbHQ7L3NjcmlwdCZndDtcbiZsdDsvYm9keSZndDtcbiZsdDsvaHRtbCZndDtcbjwvY29kZT48L3ByZT5cbjxwPuWmguS4iu+8jOW8leWFpeS6hiBhL2IvYy9kL2Ug5LqU5Liq5paH5Lu277yM6L+Z5LqU5Liq5paH5Lu25aaC5p6c55u45LqS5LmL6Ze05pyJ5L6d6LWW77yM6L+Y6KaB5rOo5oSP5byV5YWl55qE6aG65bqP77yM5bm25LiU6L+Y6ZyA6KaB5rOo5oSP5a6D5Lus6YeM6Z2i55qE5Y+Y6YeP5ZCN77yM6Iul5piv6YeN5aSN5Yip55So5Yiw5YW25LuW55qE6aG555uu77yM5YW25LuW6aG555uu5Lmf6ZyA6KaB5rOo5oSP5Yiw5Lul5LiK5Lik54K56Zeu6aKY44CC5Li65LqG6Kej5Yaz6L+Z5LiA6Zeu6aKY77yM5bCx5pyJ5LqG5qih5Z2X5YyW55qE6KeE6IyD44CCPC9wPlxuPHA+5qih5Z2X5YyW55qE6KeE6IyD77yM5pyJIDxhIGhyZWY9XCJodHRwOi8vamF2YXNjcmlwdC5ydWFueWlmZW5nLmNvbS9ub2RlanMvbW9kdWxlLmh0bWxcIj5DTUQ8L2E+ICDlkowgPGEgaHJlZj1cImh0dHA6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEyLzEwL2FzeW5jaHJvbm91c19tb2R1bGVfZGVmaW5pdGlvbi5odG1sXCI+QU1EPC9hPjwvcD5cbjxwPkNNRCAoQ29tbW9uIE1vZHVsZSBEZWZpbml0aW9uKSwg5pivc2VhLmpz5Zyo5o6o5bm/6L+H56iL5Lit5a+55qih5Z2X5a6a5LmJ55qE6KeE6IyD5YyW5Lqn5Ye677yM5Li76KaB55So5LqO5rWP6KeI5Zmo56uv44CC5a6D5Li76KaB54m554K55piv77ya5a+55LqO5L6d6LWW55qE5qih5Z2X5piv5bu26L+f5omn6KGM77yM5L6d6LWW5Y+v5Lul5bCx6L+R5Lmm5YaZ77yM562J5Yiw6ZyA6KaB55So6L+Z5Liq5L6d6LWW55qE5pe25YCZ5YaN5byV5YWl6L+Z5Liq5L6d6LWW77yM5bqU55So5pyJc2VhLmpzLjwvcD5cbjxwPkFNROinhOiMg++8iEFzeW5jaHJvbm91cyBNb2R1bGUgRGVmaW5pdGlvbu+8ie+8muaYryBSZXF1aXJlSlMg5Zyo5o6o5bm/6L+H56iL5Lit5a+55qih5Z2X5a6a5LmJ55qE6KeE6IyD5YyW5Lqn5Ye677yM5Lmf5piv5Li76KaB55So5LqO5rWP6KeI5Zmo56uv44CC5YW254m554K55piv77ya5L6d6LWW5YmN572u77yM6ZyA6KaB5Zyo5a6a5LmJ5pe25bCx5YaZ5aW96ZyA6KaB55qE5L6d6LWW77yM5o+Q5YmN5omn6KGM5L6d6LWW77yM5bqU55So5pyJcmVxdWlyZS5qczwvcD5cbjxwPuWwveaDheeahOeMnOa1i++8jHJlcXVpcmUuanMg5piv5oCO5LmI5byE55qE5ZGi77yfIOWug+mcgOimgeS+neasoeeahOWKoOi9veaooeWdl+eEtuWQjuWOu+i/m+ihjOebuOW6lOeahOaTjeS9nO+8jOWKoOi9veaooeWdl+WwseaYr+imgeW8leWFpei/meS4quaWh+S7tu+8jOmCo+S5iOi/memHjOS5n+i/mOaYr+mAmui/h+WKqOaAgeWKoOi9vSBzY3JpcHQg55qE5pa55rOV77yM5bm26YCa6L+HIG9ubG9hZCDljrvmiafooYzlkI7pnaLnmoTlm57osIPkuobjgII8L3A+XG48cD7miJHku6znn6XpgZPnjrDlpoLku4ogZXM2IOW3sue7j+aUr+aMgeaooeWdl+WMluS6hu+8jOWug+WIhuS4uiBleHBvcnQg5ZKMIGltcG9ydCDkuKTkuKrlkb3ku6TjgIIgZXhwb3J0IOWvvOWHuuS9oOWumuS5ieeahOaooeWdl+WPmOmHj++8jCBpbXBvcnQg5byV5YWl5LiA5Liq5qih5Z2X5Y+Y6YeP44CCPC9wPlxuPHByZSB2LXByZT1cIlwiPjxjb2RlPmV4cG9ydCB7IFxuIFx0b25lLCBcbiBcdHR3b1xuIH1cbiBleHBvcnQgZGVmYXVsdCB0aHJlZTtcbjwvY29kZT48L3ByZT5cbjxwPuWvueW6lOeahOW8leWFpeS7o+eggTwvcD5cbjxwcmUgdi1wcmU9XCJcIj48Y29kZT5pbXBvcnQgIHsgb25lLCB0d28gfSAgdGhyZWUgZnJvbSAnYS5qcydcbjwvY29kZT48L3ByZT5cbjxwPuWPr+S7peeci+WIsCBleHBvcnQg5Y+v5Lul5a+85Ye65LiA5Liq6buY6K6k55qE5Y+Y6YeP77yM5Lmf5Y+v5Lul5a+85Ye65Y+Y6YeP5a+56LGh77yM6L+Z6YeM5byV5YWl55qE5pe25YCZ5ZCN5a2X5LiN6KaB5YaZ6ZSZ5LqG44CCIOmCo+S5iCBlczYg55qE5qih5Z2X5YyW6YCa6L+HYmFiZWwg6L2s56CB5YW25a6e5bCx5pivIHVtZCDmqKHlnZfop4TojIPvvIwg5a6D5piv5LiA5Liq5YW85a65IGNtZCDlkowgYW1kIOeahOaooeWdl+WMluinhOiMgywg5ZCM5pe26L+Y5pSv5oyB6ICB5byP55qE4oCc5YWo5bGA4oCd5Y+Y6YeP6KeE6IyDPC9wPlxuPHByZSB2LXByZT1cIlwiPjxjb2RlPihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICZhbXA7JmFtcDsgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUsIENvbW1vbkpT5LmL57G755qEXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8g5rWP6KeI5Zmo5YWo5bGA5Y+Y6YePKHJvb3Qg5Y2zIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeShyb290LmpRdWVyeSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoJCkge1xuICAgIC8vICAgIOaWueazlVxuICAgIGZ1bmN0aW9uIG15RnVuYygpe307XG4gXG4gICAgLy8gICAg5pq06Zyy5YWs5YWx5pa55rOVXG4gICAgcmV0dXJuIG15RnVuYztcbn0pKTtcbjwvY29kZT48L3ByZT5cbjxwPumCo+S5iOa1j+iniOWZqOaYr+WmguS9leaUr+aMgei/meenjeinhOiMg+eahOWRou+8n1xu5YW25a6e5piv5a6e546w5LqG5qC55o2u6L+Z56eN6KeE6IyD5a6a5Yi25Ye65p2l55qE5Yqf6IO944CC6L+Z6YeM5oiR5Lus5bCx5oyJ54WnIOWunueOsOS6hiBBTUQg6KeE6IyD55qEIHJlcXVpcmUuanMg5p2l6K6y5LiA5LiL5a6e546w5Luj56CB44CCPC9wPlxuPHA+QU1EIOWumuS5ieS4gOS4quaooeWdl+eahOaWueazleaYryBkZWZpbmUoaWQ/LCBkZXBlbmRlbmNpZXM/LCBmYWN0b3J5KeOAgjwvcD5cbjxwPuWPguiAg2RlZmluZSDnmoTmlrnms5Xku6PnoIE8L3A+XG48cHJlIHYtcHJlPVwiXCI+PGNvZGU+IGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm9kZSwgY29udGV4dDtcbiAgICAgICAgXG4gICAgICAgIC8vQWxsb3cgZm9yIGFub255bW91cyBtb2R1bGVzXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgYXBwcm9wcmlhdGVseVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVGhpcyBtb2R1bGUgbWF5IG5vdCBoYXZlIGRlcGVuZGVuY2llc1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiBubyBuYW1lLCBhbmQgY2FsbGJhY2sgaXMgYSBmdW5jdGlvbiwgdGhlbiBmaWd1cmUgb3V0IGlmIGl0IGFcbiAgICAgICAgLy9Db21tb25KUyB0aGluZyB3aXRoIGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKCFkZXBzICZhbXA7JmFtcDsgaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgICAgIC8v56e76Zmk5rOo6YeKXG4gICAgICAgICAgICAvL+afpeaJviByZXF1aXJlIOivreWPpe+8jOaUtumbhuS+nei1luWIsCBkZXBzIOmHjOmdolxuICAgICAgICAgICAgLy8gYnV0IG9ubHkgaWYgdGhlcmUgYXJlIGZ1bmN0aW9uIGFyZ3MuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoY29tbWVudFJlZ0V4cCwgY29tbWVudFJlcGxhY2UpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKGNqc1JlcXVpcmVSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgZGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL01heSBiZSBhIENvbW1vbkpTIHRoaW5nIGV2ZW4gd2l0aG91dCByZXF1aXJlIGNhbGxzLCBidXQgc3RpbGxcbiAgICAgICAgICAgICAgICAvL2NvdWxkIHVzZSBleHBvcnRzLCBhbmQgbW9kdWxlLiBBdm9pZCBkb2luZyBleHBvcnRzIGFuZCBtb2R1bGVcbiAgICAgICAgICAgICAgICAvL3dvcmsgdGhvdWdoIGlmIGl0IGp1c3QgbmVlZHMgcmVxdWlyZS5cbiAgICAgICAgICAgICAgICAvL1JFUVVJUkVTIHRoZSBmdW5jdGlvbiB0byBleHBlY3QgdGhlIENvbW1vbkpTIHZhcmlhYmxlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvL29yZGVyIGxpc3RlZCBiZWxvdy5cbiAgICAgICAgICAgICAgICBkZXBzID0gKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSA/IFsncmVxdWlyZSddIDogWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ10pLmNvbmNhdChkZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vSWYgaW4gSUUgNi04IGFuZCBoaXQgYW4gYW5vbnltb3VzIGRlZmluZSgpIGNhbGwsIGRvIHRoZSBpbnRlcmFjdGl2ZVxuICAgICAgICAvL3dvcmsuXG4gICAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRseUFkZGluZ1NjcmlwdCB8fCBnZXRJbnRlcmFjdGl2ZVNjcmlwdCgpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXJlcXVpcmVtb2R1bGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHRzW25vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXJlcXVpcmVjb250ZXh0JyldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9BbHdheXMgc2F2ZSBvZmYgZXZhbHVhdGluZyB0aGUgZGVmIGNhbGwgdW50aWwgdGhlIHNjcmlwdCBvbmxvYWQgaGFuZGxlci5cbiAgICAgICAgLy9UaGlzIGFsbG93cyBtdWx0aXBsZSBtb2R1bGVzIHRvIGJlIGluIGEgZmlsZSB3aXRob3V0IHByZW1hdHVyZWx5XG4gICAgICAgIC8vdHJhY2luZyBkZXBlbmRlbmNpZXMsIGFuZCBhbGxvd3MgZm9yIGFub255bW91cyBtb2R1bGUgc3VwcG9ydCxcbiAgICAgICAgLy93aGVyZSB0aGUgbW9kdWxlIG5hbWUgaXMgbm90IGtub3duIHVudGlsIHRoZSBzY3JpcHQgb25sb2FkIGV2ZW50XG4gICAgICAgIC8vb2NjdXJzLiBJZiBubyBjb250ZXh0LCB1c2UgdGhlIGdsb2JhbCBxdWV1ZSwgYW5kIGdldCBpdCBwcm9jZXNzZWRcbiAgICAgICAgLy9pbiB0aGUgb25zY3JpcHQgbG9hZCBjYWxsYmFjay5cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVmUXVldWUucHVzaChbbmFtZSwgZGVwcywgY2FsbGJhY2tdKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGVmUXVldWVNYXBbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsRGVmUXVldWUucHVzaChbbmFtZSwgZGVwcywgY2FsbGJhY2tdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUuYW1kID0ge1xuICAgICAgICBqUXVlcnk6IHRydWVcbiAgICB9O1xuICAgIFxuXHRyZXEuZXhlYyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUgKi9cbiAgICAgICAgcmV0dXJuIGV2YWwodGV4dCk7XG4gICAgfTtcblxuICAgIC8vU2V0IHVwIHdpdGggY29uZmlnIGluZm8uXG4gICAgcmVxKGNmZyk7XG48L2NvZGU+PC9wcmU+XG48cD7lj6/ku6Xnn6XpgZPvvIzov5nkuIDmrrXku6PnoIHmmK/op6PmnpDlrprkuYnmmK/mqKHlnZfmiYDpnIDnmoTkvp3otZbmlL7nva4gY29udGV4dCDnmoTmqKHlnZflrprkuYnpmJ/liJfkuK3jgILnhLblkI7miJHku6zlsLHopoHpgJrov4cgcmVxIOWOu+aJp+ihjOWKoOi9veS+nei1lu+8jOaIkeS7rOadpeeci+eciyByZXEg55qE5a6a5LmJ44CCPC9wPlxuPHByZSB2LXByZT1cIlwiPjxjb2RlPnJlcSA9IHJlcXVpcmVqcyA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgZXJyYmFjaywgb3B0aW9uYWwpIHtcblxuICAgICAgICAvL0ZpbmQgdGhlIHJpZ2h0IGNvbnRleHQsIHVzZSBkZWZhdWx0XG4gICAgICAgIHZhciBjb250ZXh0LCBjb25maWcsXG4gICAgICAgICAgICBjb250ZXh0TmFtZSA9IGRlZkNvbnRleHROYW1lO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiBoYXZlIGNvbmZpZyBvYmplY3QgaW4gdGhlIGNhbGwuXG4gICAgICAgIGlmICghaXNBcnJheShkZXBzKSAmYW1wOyZhbXA7IHR5cGVvZiBkZXBzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZGVwcyBpcyBhIGNvbmZpZyBvYmplY3RcbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgZGVwcyA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyYmFjaztcbiAgICAgICAgICAgICAgICBlcnJiYWNrID0gb3B0aW9uYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcgJmFtcDsmYW1wOyBjb25maWcuY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dE5hbWUgPSBjb25maWcuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNvbmZpZ3VyZShjb25maWcpOyAvLyDlrozlloTphY3nva5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlcXVpcmUoZGVwcywgY2FsbGJhY2ssIGVycmJhY2spOyBcbjwvY29kZT48L3ByZT5cbjxwPui/memHjOeahOS7o+eggeaKiiDkvp3otZbvvIzlm57osIPvvIwg6ZSZ6K+v5aSE55CG5ZKM6YWN572u6aG56YO95Lyg6L+b5p2l5LqG77yM6L+b6KGM5LqG6YWN572u5LiK55qE5aSE55CG5LmL5ZCO77yM5oiR5Lus5Y+v5Lul55yL5Yiw5pyA5ZCO5YaN5Y675qC55o2u6YWN572u5Yqg6L2944CCXG7miJHku6zlho3mnaXnnIsgY29udGV4dC5yZXF1aXJlIOaWueazlTwvcD5cbjxwcmUgdi1wcmU9XCJcIj48Y29kZT5tYWtlUmVxdWlyZTogZnVuY3Rpb24gKHJlbE1hcCwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGZ1bmN0aW9uIGxvY2FsUmVxdWlyZShkZXBzLCBjYWxsYmFjaywgZXJyYmFjaykge1xuXHRcdFx0Li4uLiDlvZPliY0gcmVxdWlyZSDnmoTovazmjaJcbiAgICAgIFx0IFx0cmV0dXJuIGxvY2FsUmVxdWlyZTtcbiAgXHRcdCB9XG5cdFx0Y29tcGxldGVMb2FkOiBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuXHRcdFx05Yik5patIGNvbnRleHQg55qE5L6d6LWW6Zif5YiX77yM5piv57un57ut5Yqg6L296L+Y5piv5omn6KGM5Zue6LCDXG5cdFx0fVxuXHRcdCBuYW1lVG9Vcmw6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBleHQsIHNraXBFeHQpIHtcblx0XHQgXHTmoLnmja7mqKHlnZflkI3lkozphY3nva7lvpfliLDliqDovb3nmoTot6/lvoRcblx0XHQgfVxuXHRcdCBsb2FkOiBmdW5jdGlvbiAoaWQsIHVybCkge1xuXHQgICAgICAgICAgICAgICByZXEubG9hZChjb250ZXh0LCBpZCwgdXJsKTtcblx0ICAgICAgfSxcblx0ICAgICAgZXhlY0NiOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGFyZ3MsIGV4cG9ydHMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShleHBvcnRzLCBhcmdzKTtcblx0ICAgICAgICB9LFxuXHRcdG9uU2NyaXB0TG9hZDogZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx06ISa5pys5Yqg6L295a6M5oiQ5ZCO5b6X5Yiw5pWw5o2u77yM5omn6KGMIGNvbnRleHQuY29tcGxldGVMb2FkKGRhdGEuaWQpO1xuXHRcdH1cblx0XHRvblNjcmlwdEVycm9yOiBmdW5jdGlvbiAoZXZ0KSB7XG5cdFx0XHTliqDovb3plJnor6/miafooYzplJnor6/lpITnkIZcblx0XHR9XG5cdH07XG4gICBjb250ZXh0LnJlcXVpcmUgPSBjb250ZXh0Lm1ha2VSZXF1aXJlKCk7XG48L2NvZGU+PC9wcmU+XG48cD7pgqPmiJHku6znn6XpgZPlhbblrp7lsLHmmK/lm7TnnYDov5nor63ms5XnmoTop6PmnpDvvIzov5vooYzkuIDns7vliJfnmoTohJrmnKzliqDovb3vvIznhLblkI7miafooYzlm57osIPjgII8L3A+XG48L2Rpdj48L3RlbXBsYXRlPiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL21vZHVsZS5tZD92dWUmdHlwZT10ZW1wbGF0ZSZpZD02YTZmOTgzNFwiXG5jb25zdCBzY3JpcHQgPSB7fVxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNy40LjJfQHZ1ZStjb21waWxlci1zZmNAMy41LjEyX3Z1ZUAzLjUuMTJfdHlwZXNjcmlwdEA1LjYuM19fd2VicGFja0A1Ljk1LjBfd2VicGFjay1jbGlANS4xLjRfL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIl0sIm5hbWVzIjpbImNsYXNzIiwic2NyaXB0IiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9ob2lzdGVkXzEiLCJfY2FjaGUiLCJfY3JlYXRlU3RhdGljVk5vZGUiXSwic291cmNlUm9vdCI6IiJ9