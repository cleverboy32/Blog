"use strict";(self.webpackChunkreact_wyz=self.webpackChunkreact_wyz||[]).push([[672],{2672:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r='### 找出数组中和为 target 的两个数的 index\n\n```js\nfunction twoSum(array, target) {\n    const map = new Map();\n    for (let i = 0; i < array.length; i++) {\n        const rest = target - array[i];\n        if (map.has(rest)) {\n            return [map.get(rest), i];\n        }\n        map.set(array[i], i);\n    }\n    return [];\n}\n```\n\n###  使用promise+async await 实现一个函数，运行这个函数 先输出1 然后3s之后输出2\n\n\n```js\nfunction sleep (time) {\n\treturn new Promise((reslove) => {\n\t\tsetTimeout(() => { reslove() }, time)\n\t\t\n\t});\n}\n\n\nasync function  task () {\n\tconsole.log(1);\n\tawait sleep(3000);\n\tconsole.log(2);\n}\n```\n\n\n\n### 将两个递增数组合并成一个数组，且是递增的\n\n```js\nfunction mergeArray(array1, array2) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < array1.length && j < array2.length) {\n        result.push(array1[i] < array2[j] ? array1[i++] : array2[j++]);\n    }\n    return result.concat(array1.slice(i)).concat(array2.slice(j));\n}\n```\n\n### 如何用 lerna 管理 monorepo\n\n\n// ... existing code ...\n\n### 如何用 lerna 管理 monorepo\n\nLerna 是一个用于管理包含多个包（packages）的 JavaScript 项目的工具。以下是使用 Lerna 管理 monorepo 的基本步骤：\n\n1. **初始化 Lerna 项目**\n\n```bash\n# 安装 lerna\nnpm install --global lerna\n\n# 创建新的 lerna 项目\nmkdir my-lerna-repo && cd my-lerna-repo\nlerna init\n```\n\n2. **项目结构**\n\n```\nmy-lerna-repo/\n  packages/\n    package-1/\n      package.json\n    package-2/\n      package.json\n  package.json\n  lerna.json\n```\n\n3. **配置 lerna.json**\n\n```json\n{\n  "version": "1.0.0",\n  "npmClient": "npm",\n  "command": {\n    "publish": {\n      "ignoreChanges": ["ignored-file", "*.md"],\n      "message": "chore(release): publish"\n    },\n    "bootstrap": {\n      "ignore": "component-*",\n      "npmClientArgs": ["--no-package-lock"]\n    }\n  },\n  "packages": ["packages/*"]\n}\n```\n\n4. **常用命令**\n\n```bash\n# 安装所有依赖\nlerna bootstrap\n\n# 创建新包\nlerna create package-name\n\n# 为所有包添加依赖\nlerna add module-1 --scope=module-2\n\n# 发布包\nlerna publish\n\n# 执行每个包中的脚本\nlerna run test\n```\n\n5. **工作流程最佳实践**\n\n- 使用 `lerna bootstrap` 安装依赖\n- 使用 `lerna clean` 清理依赖\n- 使用 `lerna changed` 查看修改的包\n- 使用 `lerna diff` 查看具体改动\n- 使用 `lerna version` 更新版本号\n- 使用 `lerna publish` 发布包\n\n6. **版本控制策略**\n\n- Fixed/Locked mode (默认): 所有包使用同一版本号\n- Independent mode: 每个包独立版本号管理\n\n```bash\n# 使用独立版本模式初始化\nlerna init --independent\n```\n\n\n7. **使用 workspace 协议引用本地包**\n\n```json\n{\n  "dependencies": {\n    "@my-scope/package-1": "workspace:*"\n  }\n}\n```\n\n8. 引用本地包时，不打包引用的本地包\n\nwebpack 配置\n\n``` js\nexternals: [\n  // 方法1：使用正则匹配所有本地包\n  /^@my-scope\\/.+$/,\n]\n```\n\npackage.json 添加前置依赖包\n\n```json\n"peerDependencies": {\n  // 将本地包声明为 peerDependencies\n  "@my-scope/package-1": ""\n}\n```\n\n\n9. 组件库的整体打包和单组件模块打包配置\n\nwebpack 配置整体入口和单组件入口\n\n```js\n\n// 整体入口\nentry: {\n  index: \'./src/index.js\'\n}\n\n// 单组件入口\nentry: [\n  Button: \'./src/Button/index.js\',\n  Input: \'./src/Input/index.js\',\n  Select: \'./src/Select/index.js\',\n  ...\n]\n\n```\n\n\n### 实现一个 deepClone\n\n```js\nfunction deepClone(obj) {\n  if (typeof obj !== \'object\' || obj === null) return obj;\n  const newObj = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n\n    console.log(key, obj[key])\n    newObj[key] = deepClone(obj[key]);\n  }\n  return newObj;\n}\n```\n\n\n### 实现一个封装的 useRequest 请求库\n\n\n```js\n\nclass HttpError extends Error {\n  constructor(message, status) {\n    super(message);\n    this.status = status;\n  }\n}\n\n\n\nclass RequestClient {\n  constructor(defaultConfig = {}) {\n    this.defaultConfig = {\n      timeout: 10000,\n      retryTimes: 3,\n      ...defaultConfig\n    };\n  }\n\n  async request(params) {\n    const config = { ...this.defaultConfig, ...params };\n    const { url, method = \'GET\', headers = {}, timeout, retryTimes } = config;\n\n    const executeRequest = async (attempt = 0) => {\n      try {\n        const controller = new AbortController();  // 创建一个 AbortController 实例\n        const timeoutId = setTimeout(() => controller.abort(), timeout); // 设置超时\n\n        const response = await fetch(url, {\n          method,\n          headers,\n          signal: controller.signal, // 将 AbortController 的 signal 传递给 fetch  \n          ...config\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new HttpError(`HTTP Error: ${response.statusText}`, response.status);\n        }\n\n        const data = await response.json(); // 解析响应数据\n        return {\n          data,\n          status: response.status\n        };\n\n      } catch (error) {\n        if (attempt < retryTimes - 1) {\n          // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n          return executeRequest(attempt + 1);\n        }\n        throw error;\n      }\n    };\n\n    return executeRequest();\n  }\n\n  // Convenience methods\n  get(url, config = {}) {\n    return this.request({ ...config, url, method: \'GET\' });\n  }\n\n  post(url, data, config = {}) {\n    return this.request({\n      ...config,\n      url,\n      method: \'POST\',\n      body: JSON.stringify(data)\n    });\n  }\n}\n\n// Hook implementation\nfunction useRequest(requestFn, options = {}) {\n  const {\n    manual = false,\n    defaultData = null,\n    onSuccess,\n    onError\n  } = options;\n\n  const [data, setData] = useState(defaultData);\n  const [loading, setLoading] = useState(!manual);\n  const [error, setError] = useState(null);\n\n  const run = async (...args) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await requestFn(...args);\n      setData(result.data);\n      onSuccess?.(result);\n      return result;\n    } catch (err) {\n      setError(err);\n      onError?.(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    if (!manual) {\n      run();\n    }\n  }, []);\n\n  return {\n    data,\n    loading,\n    error,\n    run\n  };\n}\n\n// Usage example:\nconst client = new RequestClient({\n  timeout: 5000,\n  retryTimes: 3\n});\n\n// In component:\nconst { data, loading, error, run } = useRequest(\n  () => client.get(\'https://api.example.com/data\'),\n  {\n    manual: true,\n    onSuccess: (result) => console.log(\'Success:\', result),\n    onError: (error) => console.error(\'Error:\', error)\n  }\n);\n```\n'}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcyLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoibUlBQUEsc3RNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3Rfd3l6Ly4uLy4uL2Jsb2dzL21hcmtkb3duL3ctZXJtaWFuLm1kIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiIyMjIOaJvuWHuuaVsOe7hOS4reWSjOS4uiB0YXJnZXQg55qE5Lik5Liq5pWw55qEIGluZGV4XFxuXFxuYGBganNcXG5mdW5jdGlvbiB0d29TdW0oYXJyYXksIHRhcmdldCkge1xcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNvbnN0IHJlc3QgPSB0YXJnZXQgLSBhcnJheVtpXTtcXG4gICAgICAgIGlmIChtYXAuaGFzKHJlc3QpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFttYXAuZ2V0KHJlc3QpLCBpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIG1hcC5zZXQoYXJyYXlbaV0sIGkpO1xcbiAgICB9XFxuICAgIHJldHVybiBbXTtcXG59XFxuYGBgXFxuXFxuIyMjICDkvb/nlKhwcm9taXNlK2FzeW5jIGF3YWl0IOWunueOsOS4gOS4quWHveaVsO+8jOi/kOihjOi/meS4quWHveaVsCDlhYjovpPlh7oxIOeEtuWQjjNz5LmL5ZCO6L6T5Ye6MlxcblxcblxcbmBgYGpzXFxuZnVuY3Rpb24gc2xlZXAgKHRpbWUpIHtcXG5cXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc2xvdmUpID0+IHtcXG5cXHRcXHRzZXRUaW1lb3V0KCgpID0+IHsgcmVzbG92ZSgpIH0sIHRpbWUpXFxuXFx0XFx0XFxuXFx0fSk7XFxufVxcblxcblxcbmFzeW5jIGZ1bmN0aW9uICB0YXNrICgpIHtcXG5cXHRjb25zb2xlLmxvZygxKTtcXG5cXHRhd2FpdCBzbGVlcCgzMDAwKTtcXG5cXHRjb25zb2xlLmxvZygyKTtcXG59XFxuYGBgXFxuXFxuXFxuXFxuIyMjIOWwhuS4pOS4qumAkuWinuaVsOe7hOWQiOW5tuaIkOS4gOS4quaVsOe7hO+8jOS4lOaYr+mAkuWinueahFxcblxcbmBgYGpzXFxuZnVuY3Rpb24gbWVyZ2VBcnJheShhcnJheTEsIGFycmF5Mikge1xcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcXG4gICAgbGV0IGkgPSAwLCBqID0gMDtcXG4gICAgd2hpbGUgKGkgPCBhcnJheTEubGVuZ3RoICYmIGogPCBhcnJheTIubGVuZ3RoKSB7XFxuICAgICAgICByZXN1bHQucHVzaChhcnJheTFbaV0gPCBhcnJheTJbal0gPyBhcnJheTFbaSsrXSA6IGFycmF5MltqKytdKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChhcnJheTEuc2xpY2UoaSkpLmNvbmNhdChhcnJheTIuc2xpY2UoaikpO1xcbn1cXG5gYGBcXG5cXG4jIyMg5aaC5L2V55SoIGxlcm5hIOeuoeeQhiBtb25vcmVwb1xcblxcblxcbi8vIC4uLiBleGlzdGluZyBjb2RlIC4uLlxcblxcbiMjIyDlpoLkvZXnlKggbGVybmEg566h55CGIG1vbm9yZXBvXFxuXFxuTGVybmEg5piv5LiA5Liq55So5LqO566h55CG5YyF5ZCr5aSa5Liq5YyF77yIcGFja2FnZXPvvInnmoQgSmF2YVNjcmlwdCDpobnnm67nmoTlt6XlhbfjgILku6XkuIvmmK/kvb/nlKggTGVybmEg566h55CGIG1vbm9yZXBvIOeahOWfuuacrOatpemqpO+8mlxcblxcbjEuICoq5Yid5aeL5YyWIExlcm5hIOmhueebrioqXFxuXFxuYGBgYmFzaFxcbiMg5a6J6KOFIGxlcm5hXFxubnBtIGluc3RhbGwgLS1nbG9iYWwgbGVybmFcXG5cXG4jIOWIm+W7uuaWsOeahCBsZXJuYSDpobnnm65cXG5ta2RpciBteS1sZXJuYS1yZXBvICYmIGNkIG15LWxlcm5hLXJlcG9cXG5sZXJuYSBpbml0XFxuYGBgXFxuXFxuMi4gKirpobnnm67nu5PmnoQqKlxcblxcbmBgYFxcbm15LWxlcm5hLXJlcG8vXFxuICBwYWNrYWdlcy9cXG4gICAgcGFja2FnZS0xL1xcbiAgICAgIHBhY2thZ2UuanNvblxcbiAgICBwYWNrYWdlLTIvXFxuICAgICAgcGFja2FnZS5qc29uXFxuICBwYWNrYWdlLmpzb25cXG4gIGxlcm5hLmpzb25cXG5gYGBcXG5cXG4zLiAqKumFjee9riBsZXJuYS5qc29uKipcXG5cXG5gYGBqc29uXFxue1xcbiAgXFxcInZlcnNpb25cXFwiOiBcXFwiMS4wLjBcXFwiLFxcbiAgXFxcIm5wbUNsaWVudFxcXCI6IFxcXCJucG1cXFwiLFxcbiAgXFxcImNvbW1hbmRcXFwiOiB7XFxuICAgIFxcXCJwdWJsaXNoXFxcIjoge1xcbiAgICAgIFxcXCJpZ25vcmVDaGFuZ2VzXFxcIjogW1xcXCJpZ25vcmVkLWZpbGVcXFwiLCBcXFwiKi5tZFxcXCJdLFxcbiAgICAgIFxcXCJtZXNzYWdlXFxcIjogXFxcImNob3JlKHJlbGVhc2UpOiBwdWJsaXNoXFxcIlxcbiAgICB9LFxcbiAgICBcXFwiYm9vdHN0cmFwXFxcIjoge1xcbiAgICAgIFxcXCJpZ25vcmVcXFwiOiBcXFwiY29tcG9uZW50LSpcXFwiLFxcbiAgICAgIFxcXCJucG1DbGllbnRBcmdzXFxcIjogW1xcXCItLW5vLXBhY2thZ2UtbG9ja1xcXCJdXFxuICAgIH1cXG4gIH0sXFxuICBcXFwicGFja2FnZXNcXFwiOiBbXFxcInBhY2thZ2VzLypcXFwiXVxcbn1cXG5gYGBcXG5cXG40LiAqKuW4uOeUqOWRveS7pCoqXFxuXFxuYGBgYmFzaFxcbiMg5a6J6KOF5omA5pyJ5L6d6LWWXFxubGVybmEgYm9vdHN0cmFwXFxuXFxuIyDliJvlu7rmlrDljIVcXG5sZXJuYSBjcmVhdGUgcGFja2FnZS1uYW1lXFxuXFxuIyDkuLrmiYDmnInljIXmt7vliqDkvp3otZZcXG5sZXJuYSBhZGQgbW9kdWxlLTEgLS1zY29wZT1tb2R1bGUtMlxcblxcbiMg5Y+R5biD5YyFXFxubGVybmEgcHVibGlzaFxcblxcbiMg5omn6KGM5q+P5Liq5YyF5Lit55qE6ISa5pysXFxubGVybmEgcnVuIHRlc3RcXG5gYGBcXG5cXG41LiAqKuW3peS9nOa1geeoi+acgOS9s+Wunui3tSoqXFxuXFxuLSDkvb/nlKggYGxlcm5hIGJvb3RzdHJhcGAg5a6J6KOF5L6d6LWWXFxuLSDkvb/nlKggYGxlcm5hIGNsZWFuYCDmuIXnkIbkvp3otZZcXG4tIOS9v+eUqCBgbGVybmEgY2hhbmdlZGAg5p+l55yL5L+u5pS555qE5YyFXFxuLSDkvb/nlKggYGxlcm5hIGRpZmZgIOafpeeci+WFt+S9k+aUueWKqFxcbi0g5L2/55SoIGBsZXJuYSB2ZXJzaW9uYCDmm7TmlrDniYjmnKzlj7dcXG4tIOS9v+eUqCBgbGVybmEgcHVibGlzaGAg5Y+R5biD5YyFXFxuXFxuNi4gKirniYjmnKzmjqfliLbnrZbnlaUqKlxcblxcbi0gRml4ZWQvTG9ja2VkIG1vZGUgKOm7mOiupCk6IOaJgOacieWMheS9v+eUqOWQjOS4gOeJiOacrOWPt1xcbi0gSW5kZXBlbmRlbnQgbW9kZTog5q+P5Liq5YyF54us56uL54mI5pys5Y+3566h55CGXFxuXFxuYGBgYmFzaFxcbiMg5L2/55So54us56uL54mI5pys5qih5byP5Yid5aeL5YyWXFxubGVybmEgaW5pdCAtLWluZGVwZW5kZW50XFxuYGBgXFxuXFxuXFxuNy4gKirkvb/nlKggd29ya3NwYWNlIOWNj+iuruW8leeUqOacrOWcsOWMhSoqXFxuXFxuYGBganNvblxcbntcXG4gIFxcXCJkZXBlbmRlbmNpZXNcXFwiOiB7XFxuICAgIFxcXCJAbXktc2NvcGUvcGFja2FnZS0xXFxcIjogXFxcIndvcmtzcGFjZToqXFxcIlxcbiAgfVxcbn1cXG5gYGBcXG5cXG44LiDlvJXnlKjmnKzlnLDljIXml7bvvIzkuI3miZPljIXlvJXnlKjnmoTmnKzlnLDljIVcXG5cXG53ZWJwYWNrIOmFjee9rlxcblxcbmBgYCBqc1xcbmV4dGVybmFsczogW1xcbiAgLy8g5pa55rOVMe+8muS9v+eUqOato+WImeWMuemFjeaJgOacieacrOWcsOWMhVxcbiAgL15AbXktc2NvcGVcXFxcLy4rJC8sXFxuXVxcbmBgYFxcblxcbnBhY2thZ2UuanNvbiDmt7vliqDliY3nva7kvp3otZbljIVcXG5cXG5gYGBqc29uXFxuXFxcInBlZXJEZXBlbmRlbmNpZXNcXFwiOiB7XFxuICAvLyDlsIbmnKzlnLDljIXlo7DmmI7kuLogcGVlckRlcGVuZGVuY2llc1xcbiAgXFxcIkBteS1zY29wZS9wYWNrYWdlLTFcXFwiOiBcXFwiXFxcIlxcbn1cXG5gYGBcXG5cXG5cXG45LiDnu4Tku7blupPnmoTmlbTkvZPmiZPljIXlkozljZXnu4Tku7bmqKHlnZfmiZPljIXphY3nva5cXG5cXG53ZWJwYWNrIOmFjee9ruaVtOS9k+WFpeWPo+WSjOWNlee7hOS7tuWFpeWPo1xcblxcbmBgYGpzXFxuXFxuLy8g5pW05L2T5YWl5Y+jXFxuZW50cnk6IHtcXG4gIGluZGV4OiAnLi9zcmMvaW5kZXguanMnXFxufVxcblxcbi8vIOWNlee7hOS7tuWFpeWPo1xcbmVudHJ5OiBbXFxuICBCdXR0b246ICcuL3NyYy9CdXR0b24vaW5kZXguanMnLFxcbiAgSW5wdXQ6ICcuL3NyYy9JbnB1dC9pbmRleC5qcycsXFxuICBTZWxlY3Q6ICcuL3NyYy9TZWxlY3QvaW5kZXguanMnLFxcbiAgLi4uXFxuXVxcblxcbmBgYFxcblxcblxcbiMjIyDlrp7njrDkuIDkuKogZGVlcENsb25lXFxuXFxuYGBganNcXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XFxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gb2JqO1xcbiAgY29uc3QgbmV3T2JqID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xcblxcbiAgICBjb25zb2xlLmxvZyhrZXksIG9ialtrZXldKVxcbiAgICBuZXdPYmpba2V5XSA9IGRlZXBDbG9uZShvYmpba2V5XSk7XFxuICB9XFxuICByZXR1cm4gbmV3T2JqO1xcbn1cXG5gYGBcXG5cXG5cXG4jIyMg5a6e546w5LiA5Liq5bCB6KOF55qEIHVzZVJlcXVlc3Qg6K+35rGC5bqTXFxuXFxuXFxuYGBganNcXG5cXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XFxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMpIHtcXG4gICAgc3VwZXIobWVzc2FnZSk7XFxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xcbiAgfVxcbn1cXG5cXG5cXG5cXG5jbGFzcyBSZXF1ZXN0Q2xpZW50IHtcXG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRDb25maWcgPSB7fSkge1xcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XFxuICAgICAgdGltZW91dDogMTAwMDAsXFxuICAgICAgcmV0cnlUaW1lczogMyxcXG4gICAgICAuLi5kZWZhdWx0Q29uZmlnXFxuICAgIH07XFxuICB9XFxuXFxuICBhc3luYyByZXF1ZXN0KHBhcmFtcykge1xcbiAgICBjb25zdCBjb25maWcgPSB7IC4uLnRoaXMuZGVmYXVsdENvbmZpZywgLi4ucGFyYW1zIH07XFxuICAgIGNvbnN0IHsgdXJsLCBtZXRob2QgPSAnR0VUJywgaGVhZGVycyA9IHt9LCB0aW1lb3V0LCByZXRyeVRpbWVzIH0gPSBjb25maWc7XFxuXFxuICAgIGNvbnN0IGV4ZWN1dGVSZXF1ZXN0ID0gYXN5bmMgKGF0dGVtcHQgPSAwKSA9PiB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7ICAvLyDliJvlu7rkuIDkuKogQWJvcnRDb250cm9sbGVyIOWunuS+i1xcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpOyAvLyDorr7nva7otoXml7ZcXG5cXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XFxuICAgICAgICAgIG1ldGhvZCxcXG4gICAgICAgICAgaGVhZGVycyxcXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCwgLy8g5bCGIEFib3J0Q29udHJvbGxlciDnmoQgc2lnbmFsIOS8oOmAkue7mSBmZXRjaCAgXFxuICAgICAgICAgIC4uLmNvbmZpZ1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcXG5cXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihgSFRUUCBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsIHJlc3BvbnNlLnN0YXR1cyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOyAvLyDop6PmnpDlk43lupTmlbDmja5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGRhdGEsXFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzXFxuICAgICAgICB9O1xcblxcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICBpZiAoYXR0ZW1wdCA8IHJldHJ5VGltZXMgLSAxKSB7XFxuICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucG93KDIsIGF0dGVtcHQpICogMTAwMCkpO1xcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlcXVlc3QoYXR0ZW1wdCArIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gZXhlY3V0ZVJlcXVlc3QoKTtcXG4gIH1cXG5cXG4gIC8vIENvbnZlbmllbmNlIG1ldGhvZHNcXG4gIGdldCh1cmwsIGNvbmZpZyA9IHt9KSB7XFxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyAuLi5jb25maWcsIHVybCwgbWV0aG9kOiAnR0VUJyB9KTtcXG4gIH1cXG5cXG4gIHBvc3QodXJsLCBkYXRhLCBjb25maWcgPSB7fSkge1xcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcXG4gICAgICAuLi5jb25maWcsXFxuICAgICAgdXJsLFxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG4vLyBIb29rIGltcGxlbWVudGF0aW9uXFxuZnVuY3Rpb24gdXNlUmVxdWVzdChyZXF1ZXN0Rm4sIG9wdGlvbnMgPSB7fSkge1xcbiAgY29uc3Qge1xcbiAgICBtYW51YWwgPSBmYWxzZSxcXG4gICAgZGVmYXVsdERhdGEgPSBudWxsLFxcbiAgICBvblN1Y2Nlc3MsXFxuICAgIG9uRXJyb3JcXG4gIH0gPSBvcHRpb25zO1xcblxcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGUoZGVmYXVsdERhdGEpO1xcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoIW1hbnVhbCk7XFxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xcblxcbiAgY29uc3QgcnVuID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcXG4gICAgdHJ5IHtcXG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xcbiAgICAgIHNldEVycm9yKG51bGwpO1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RGbiguLi5hcmdzKTtcXG4gICAgICBzZXREYXRhKHJlc3VsdC5kYXRhKTtcXG4gICAgICBvblN1Y2Nlc3M/LihyZXN1bHQpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHNldEVycm9yKGVycik7XFxuICAgICAgb25FcnJvcj8uKGVycik7XFxuICAgICAgdGhyb3cgZXJyO1xcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgdXNlRWZmZWN0KCgpID0+IHtcXG4gICAgaWYgKCFtYW51YWwpIHtcXG4gICAgICBydW4oKTtcXG4gICAgfVxcbiAgfSwgW10pO1xcblxcbiAgcmV0dXJuIHtcXG4gICAgZGF0YSxcXG4gICAgbG9hZGluZyxcXG4gICAgZXJyb3IsXFxuICAgIHJ1blxcbiAgfTtcXG59XFxuXFxuLy8gVXNhZ2UgZXhhbXBsZTpcXG5jb25zdCBjbGllbnQgPSBuZXcgUmVxdWVzdENsaWVudCh7XFxuICB0aW1lb3V0OiA1MDAwLFxcbiAgcmV0cnlUaW1lczogM1xcbn0pO1xcblxcbi8vIEluIGNvbXBvbmVudDpcXG5jb25zdCB7IGRhdGEsIGxvYWRpbmcsIGVycm9yLCBydW4gfSA9IHVzZVJlcXVlc3QoXFxuICAoKSA9PiBjbGllbnQuZ2V0KCdodHRwczovL2FwaS5leGFtcGxlLmNvbS9kYXRhJyksXFxuICB7XFxuICAgIG1hbnVhbDogdHJ1ZSxcXG4gICAgb25TdWNjZXNzOiAocmVzdWx0KSA9PiBjb25zb2xlLmxvZygnU3VjY2VzczonLCByZXN1bHQpLFxcbiAgICBvbkVycm9yOiAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoJ0Vycm9yOicsIGVycm9yKVxcbiAgfVxcbik7XFxuYGBgXFxuXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9