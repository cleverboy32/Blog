"use strict";(self.webpackChunkreact_wyz=self.webpackChunkreact_wyz||[]).push([[707],{707:(n,e,t)=>{t.r(e),t.d(e,{default:()=>o});const o="当我们要完成一个应用的时候，会根据对应的功能划分为许多不同的模块，就像一个论坛，有发帖的模块，评论的模块，js 中的模块也正是如此，一个具体功能的代码抽成一个文件，当你做一个东西的时候需要用到这个功能的时，可以直接使用这个文件，实现功能的分离，并能在多个需要的地方使用。就像是螺丝钉、螺丝帽、垫片一样的，通过组合使用实现出你的产品。\n\n通过直白的描述，我们可以知道，模块化的好处就是，抽离代码，重复使用，如现在很直观的代表 npm 包。\n\n\n\n那么模块化到底是怎么实现的呢？\n\n先来了解一下历史，以前的 html 不知道大家还记不记的， 一个html 页面引入了多个 js 文件.\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>So UI - A Component Library for Vue.js.</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n    <script src=\"a.js\"><\/script>\n    <script src=\"b.js\"><\/script>\n    <script src=\"c.js\"><\/script>\n    <script src=\"d.js\"><\/script>\n    <script src=\"e.js\"><\/script>\n</body>\n</html>\n```\n如上，引入了 a/b/c/d/e 五个文件，这五个文件如果相互之间有依赖，还要注意引入的顺序，并且还需要注意它们里面的变量名，若是重复利用到其他的项目，其他项目也需要注意到以上两点问题。为了解决这一问题，就有了模块化的规范。\n\n模块化的规范，有 [CMD](http://javascript.ruanyifeng.com/nodejs/module.html)  和 [AMD](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)\n\nCMD (Common Module Definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。它主要特点是：对于依赖的模块是延迟执行，依赖可以就近书写，等到需要用这个依赖的时候再引入这个依赖，应用有sea.js.\n\nAMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js\n\n尽情的猜测，require.js 是怎么弄的呢？ 它需要依次的加载模块然后去进行相应的操作，加载模块就是要引入这个文件，那么这里也还是通过动态加载 script 的方法，并通过 onload 去执行后面的回调了。\n\n我们知道现如今 es6 已经支持模块化了，它分为 export 和 import 两个命令。 export 导出你定义的模块变量， import 引入一个模块变量。\n\n```\nexport { \n \tone, \n \ttwo\n }\n export default three;\n ```\n 对应的引入代码\n ```\n import  { one, two }  three from 'a.js'\n```\n可以看到 export 可以导出一个默认的变量，也可以导出变量对象，这里引入的时候名字不要写错了。 那么 es6 的模块化通过babel 转码其实就是 umd 模块规范， 它是一个兼容 cmd 和 amd 的模块化规范, 同时还支持老式的“全局”变量规范\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS之类的\n        module.exports = factory(require('jquery'));\n    } else {\n        // 浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    方法\n    function myFunc(){};\n \n    //    暴露公共方法\n    return myFunc;\n}));\n```\n那么浏览器是如何支持这种规范的呢？\n其实是实现了根据这种规范定制出来的功能。这里我们就按照 实现了 AMD 规范的 require.js 来讲一下实现代码。\n\nAMD 定义一个模块的方法是 define(id?, dependencies?, factory)。\n\n参考define 的方法代码\n```\n define = function (name, deps, callback) {\n        var node, context;\n        \n        //Allow for anonymous modules\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps && isFunction(callback)) {\n            deps = [];\n            //移除注释\n            //查找 require 语句，收集依赖到 deps 里面\n            // but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, commentReplace)\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute('data-requiremodule');\n                }\n                context = contexts[node.getAttribute('data-requirecontext')];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        if (context) {\n            context.defQueue.push([name, deps, callback]);\n            context.defQueueMap[name] = true;\n        } else {\n            globalDefQueue.push([name, deps, callback]);\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n    \n\treq.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n```\n可以知道，这一段代码是解析定义是模块所需的依赖放置 context 的模块定义队列中。然后我们就要通过 req 去执行加载依赖，我们来看看 req 的定义。\n```\nreq = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n       \n        if (config) {\n            context.configure(config); // 完善配置\n        }\n\n        return context.require(deps, callback, errback); \n```\n这里的代码把 依赖，回调， 错误处理和配置项都传进来了，进行了配置上的处理之后，我们可以看到最后再去根据配置加载。\n我们再来看 context.require 方法\n```\nmakeRequire: function (relMap, options) {\n\t\toptions = options || {};\n\t\tfunction localRequire(deps, callback, errback) {\n\t\t\t.... 当前 require 的转换\n      \t \treturn localRequire;\n  \t\t }\n\t\tcompleteLoad: function (moduleName) {\n\t\t\t判断 context 的依赖队列，是继续加载还是执行回调\n\t\t}\n\t\t nameToUrl: function (moduleName, ext, skipExt) {\n\t\t \t根据模块名和配置得到加载的路径\n\t\t }\n\t\t load: function (id, url) {\n\t               req.load(context, id, url);\n\t      },\n\t      execCb: function (name, callback, args, exports) {\n\t                return callback.apply(exports, args);\n\t        },\n\t\tonScriptLoad: function (evt) {\n\t\t\t脚本加载完成后得到数据，执行 context.completeLoad(data.id);\n\t\t}\n\t\tonScriptError: function (evt) {\n\t\t\t加载错误执行错误处理\n\t\t}\n\t};\n   context.require = context.makeRequire();\n```\n那我们知道其实就是围着这语法的解析，进行一系列的脚本加载，然后执行回调。\n\n"}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA3LmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoia0lBQUEsODhOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3Rfd3l6Ly4uLy4uL2Jsb2dzL21hcmtkb3duL21vZHVsZS5tZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIuW9k+aIkeS7rOimgeWujOaIkOS4gOS4quW6lOeUqOeahOaXtuWAme+8jOS8muagueaNruWvueW6lOeahOWKn+iDveWIkuWIhuS4uuiuuOWkmuS4jeWQjOeahOaooeWdl++8jOWwseWDj+S4gOS4quiuuuWdm++8jOacieWPkeW4lueahOaooeWdl++8jOivhOiuuueahOaooeWdl++8jGpzIOS4reeahOaooeWdl+S5n+ato+aYr+WmguatpO+8jOS4gOS4quWFt+S9k+WKn+iDveeahOS7o+eggeaKveaIkOS4gOS4quaWh+S7tu+8jOW9k+S9oOWBmuS4gOS4quS4nOilv+eahOaXtuWAmemcgOimgeeUqOWIsOi/meS4quWKn+iDveeahOaXtu+8jOWPr+S7peebtOaOpeS9v+eUqOi/meS4quaWh+S7tu+8jOWunueOsOWKn+iDveeahOWIhuemu++8jOW5tuiDveWcqOWkmuS4qumcgOimgeeahOWcsOaWueS9v+eUqOOAguWwseWDj+aYr+ieuuS4nemSieOAgeieuuS4neW4veOAgeWeq+eJh+S4gOagt+eahO+8jOmAmui/h+e7hOWQiOS9v+eUqOWunueOsOWHuuS9oOeahOS6p+WTgeOAglxcblxcbumAmui/h+ebtOeZveeahOaPj+i/sO+8jOaIkeS7rOWPr+S7peefpemBk++8jOaooeWdl+WMlueahOWlveWkhOWwseaYr++8jOaKveemu+S7o+egge+8jOmHjeWkjeS9v+eUqO+8jOWmgueOsOWcqOW+iOebtOingueahOS7o+ihqCBucG0g5YyF44CCXFxuXFxuXFxuXFxu6YKj5LmI5qih5Z2X5YyW5Yiw5bqV5piv5oCO5LmI5a6e546w55qE5ZGi77yfXFxuXFxu5YWI5p2l5LqG6Kej5LiA5LiL5Y6G5Y+y77yM5Lul5YmN55qEIGh0bWwg5LiN55+l6YGT5aSn5a626L+Y6K6w5LiN6K6w55qE77yMIOS4gOS4qmh0bWwg6aG16Z2i5byV5YWl5LqG5aSa5LiqIGpzIOaWh+S7ti5cXG5gYGBcXG48IURPQ1RZUEUgaHRtbD5cXG48aHRtbCBsYW5nPVxcXCJ6aC1DTlxcXCI+XFxuPGhlYWQ+XFxuICAgIDxtZXRhIGNoYXJzZXQ9XFxcIlVURi04XFxcIj5cXG4gICAgPHRpdGxlPlNvIFVJIC0gQSBDb21wb25lbnQgTGlicmFyeSBmb3IgVnVlLmpzLjwvdGl0bGU+XFxuPC9oZWFkPlxcbjxib2R5PlxcbiAgICA8ZGl2IGlkPVxcXCJhcHBcXFwiPjwvZGl2PlxcbiAgICA8c2NyaXB0IHNyYz1cXFwiYS5qc1xcXCI+PC9zY3JpcHQ+XFxuICAgIDxzY3JpcHQgc3JjPVxcXCJiLmpzXFxcIj48L3NjcmlwdD5cXG4gICAgPHNjcmlwdCBzcmM9XFxcImMuanNcXFwiPjwvc2NyaXB0PlxcbiAgICA8c2NyaXB0IHNyYz1cXFwiZC5qc1xcXCI+PC9zY3JpcHQ+XFxuICAgIDxzY3JpcHQgc3JjPVxcXCJlLmpzXFxcIj48L3NjcmlwdD5cXG48L2JvZHk+XFxuPC9odG1sPlxcbmBgYFxcbuWmguS4iu+8jOW8leWFpeS6hiBhL2IvYy9kL2Ug5LqU5Liq5paH5Lu277yM6L+Z5LqU5Liq5paH5Lu25aaC5p6c55u45LqS5LmL6Ze05pyJ5L6d6LWW77yM6L+Y6KaB5rOo5oSP5byV5YWl55qE6aG65bqP77yM5bm25LiU6L+Y6ZyA6KaB5rOo5oSP5a6D5Lus6YeM6Z2i55qE5Y+Y6YeP5ZCN77yM6Iul5piv6YeN5aSN5Yip55So5Yiw5YW25LuW55qE6aG555uu77yM5YW25LuW6aG555uu5Lmf6ZyA6KaB5rOo5oSP5Yiw5Lul5LiK5Lik54K56Zeu6aKY44CC5Li65LqG6Kej5Yaz6L+Z5LiA6Zeu6aKY77yM5bCx5pyJ5LqG5qih5Z2X5YyW55qE6KeE6IyD44CCXFxuXFxu5qih5Z2X5YyW55qE6KeE6IyD77yM5pyJIFtDTURdKGh0dHA6Ly9qYXZhc2NyaXB0LnJ1YW55aWZlbmcuY29tL25vZGVqcy9tb2R1bGUuaHRtbCkgIOWSjCBbQU1EXShodHRwOi8vd3d3LnJ1YW55aWZlbmcuY29tL2Jsb2cvMjAxMi8xMC9hc3luY2hyb25vdXNfbW9kdWxlX2RlZmluaXRpb24uaHRtbClcXG5cXG5DTUQgKENvbW1vbiBNb2R1bGUgRGVmaW5pdGlvbiksIOaYr3NlYS5qc+WcqOaOqOW5v+i/h+eoi+S4reWvueaooeWdl+WumuS5ieeahOinhOiMg+WMluS6p+WHuu+8jOS4u+imgeeUqOS6jua1j+iniOWZqOerr+OAguWug+S4u+imgeeJueeCueaYr++8muWvueS6juS+nei1lueahOaooeWdl+aYr+W7tui/n+aJp+ihjO+8jOS+nei1luWPr+S7peWwsei/keS5puWGme+8jOetieWIsOmcgOimgeeUqOi/meS4quS+nei1lueahOaXtuWAmeWGjeW8leWFpei/meS4quS+nei1lu+8jOW6lOeUqOaciXNlYS5qcy5cXG5cXG5BTUTop4TojIPvvIhBc3luY2hyb25vdXMgTW9kdWxlIERlZmluaXRpb27vvInvvJrmmK8gUmVxdWlyZUpTIOWcqOaOqOW5v+i/h+eoi+S4reWvueaooeWdl+WumuS5ieeahOinhOiMg+WMluS6p+WHuu+8jOS5n+aYr+S4u+imgeeUqOS6jua1j+iniOWZqOerr+OAguWFtueJueeCueaYr++8muS+nei1luWJjee9ru+8jOmcgOimgeWcqOWumuS5ieaXtuWwseWGmeWlvemcgOimgeeahOS+nei1lu+8jOaPkOWJjeaJp+ihjOS+nei1lu+8jOW6lOeUqOaciXJlcXVpcmUuanNcXG5cXG7lsL3mg4XnmoTnjJzmtYvvvIxyZXF1aXJlLmpzIOaYr+aAjuS5iOW8hOeahOWRou+8nyDlroPpnIDopoHkvp3mrKHnmoTliqDovb3mqKHlnZfnhLblkI7ljrvov5vooYznm7jlupTnmoTmk43kvZzvvIzliqDovb3mqKHlnZflsLHmmK/opoHlvJXlhaXov5nkuKrmlofku7bvvIzpgqPkuYjov5nph4zkuZ/ov5jmmK/pgJrov4fliqjmgIHliqDovb0gc2NyaXB0IOeahOaWueazle+8jOW5tumAmui/hyBvbmxvYWQg5Y675omn6KGM5ZCO6Z2i55qE5Zue6LCD5LqG44CCXFxuXFxu5oiR5Lus55+l6YGT546w5aaC5LuKIGVzNiDlt7Lnu4/mlK/mjIHmqKHlnZfljJbkuobvvIzlroPliIbkuLogZXhwb3J0IOWSjCBpbXBvcnQg5Lik5Liq5ZG95Luk44CCIGV4cG9ydCDlr7zlh7rkvaDlrprkuYnnmoTmqKHlnZflj5jph4/vvIwgaW1wb3J0IOW8leWFpeS4gOS4quaooeWdl+WPmOmHj+OAglxcblxcbmBgYFxcbmV4cG9ydCB7IFxcbiBcXHRvbmUsIFxcbiBcXHR0d29cXG4gfVxcbiBleHBvcnQgZGVmYXVsdCB0aHJlZTtcXG4gYGBgXFxuIOWvueW6lOeahOW8leWFpeS7o+eggVxcbiBgYGBcXG4gaW1wb3J0ICB7IG9uZSwgdHdvIH0gIHRocmVlIGZyb20gJ2EuanMnXFxuYGBgXFxu5Y+v5Lul55yL5YiwIGV4cG9ydCDlj6/ku6Xlr7zlh7rkuIDkuKrpu5jorqTnmoTlj5jph4/vvIzkuZ/lj6/ku6Xlr7zlh7rlj5jph4/lr7nosaHvvIzov5nph4zlvJXlhaXnmoTml7blgJnlkI3lrZfkuI3opoHlhpnplJnkuobjgIIg6YKj5LmIIGVzNiDnmoTmqKHlnZfljJbpgJrov4diYWJlbCDovaznoIHlhbblrp7lsLHmmK8gdW1kIOaooeWdl+inhOiMg++8jCDlroPmmK/kuIDkuKrlhbzlrrkgY21kIOWSjCBhbWQg55qE5qih5Z2X5YyW6KeE6IyDLCDlkIzml7bov5jmlK/mjIHogIHlvI/nmoTigJzlhajlsYDigJ3lj5jph4/op4TojINcXG5gYGBcXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgICAgLy8gQU1EXFxuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAvLyBOb2RlLCBDb21tb25KU+S5i+exu+eahFxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIOa1j+iniOWZqOWFqOWxgOWPmOmHjyhyb290IOWNsyB3aW5kb3cpXFxuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KHJvb3QualF1ZXJ5KTtcXG4gICAgfVxcbn0odGhpcywgZnVuY3Rpb24gKCQpIHtcXG4gICAgLy8gICAg5pa55rOVXFxuICAgIGZ1bmN0aW9uIG15RnVuYygpe307XFxuIFxcbiAgICAvLyAgICDmmrTpnLLlhazlhbHmlrnms5VcXG4gICAgcmV0dXJuIG15RnVuYztcXG59KSk7XFxuYGBgXFxu6YKj5LmI5rWP6KeI5Zmo5piv5aaC5L2V5pSv5oyB6L+Z56eN6KeE6IyD55qE5ZGi77yfXFxu5YW25a6e5piv5a6e546w5LqG5qC55o2u6L+Z56eN6KeE6IyD5a6a5Yi25Ye65p2l55qE5Yqf6IO944CC6L+Z6YeM5oiR5Lus5bCx5oyJ54WnIOWunueOsOS6hiBBTUQg6KeE6IyD55qEIHJlcXVpcmUuanMg5p2l6K6y5LiA5LiL5a6e546w5Luj56CB44CCXFxuXFxuQU1EIOWumuS5ieS4gOS4quaooeWdl+eahOaWueazleaYryBkZWZpbmUoaWQ/LCBkZXBlbmRlbmNpZXM/LCBmYWN0b3J5KeOAglxcblxcbuWPguiAg2RlZmluZSDnmoTmlrnms5Xku6PnoIFcXG5gYGBcXG4gZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XFxuICAgICAgICB2YXIgbm9kZSwgY29udGV4dDtcXG4gICAgICAgIFxcbiAgICAgICAgLy9BbGxvdyBmb3IgYW5vbnltb3VzIG1vZHVsZXNcXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAvL0FkanVzdCBhcmdzIGFwcHJvcHJpYXRlbHlcXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XFxuICAgICAgICAgICAgZGVwcyA9IG5hbWU7XFxuICAgICAgICAgICAgbmFtZSA9IG51bGw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcXG4gICAgICAgIGlmICghaXNBcnJheShkZXBzKSkge1xcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcXG4gICAgICAgICAgICBkZXBzID0gbnVsbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vSWYgbm8gbmFtZSwgYW5kIGNhbGxiYWNrIGlzIGEgZnVuY3Rpb24sIHRoZW4gZmlndXJlIG91dCBpZiBpdCBhXFxuICAgICAgICAvL0NvbW1vbkpTIHRoaW5nIHdpdGggZGVwZW5kZW5jaWVzLlxcbiAgICAgICAgaWYgKCFkZXBzICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XFxuICAgICAgICAgICAgZGVwcyA9IFtdO1xcbiAgICAgICAgICAgIC8v56e76Zmk5rOo6YeKXFxuICAgICAgICAgICAgLy/mn6Xmib4gcmVxdWlyZSDor63lj6XvvIzmlLbpm4bkvp3otZbliLAgZGVwcyDph4zpnaJcXG4gICAgICAgICAgICAvLyBidXQgb25seSBpZiB0aGVyZSBhcmUgZnVuY3Rpb24gYXJncy5cXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXFxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKVxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoY29tbWVudFJlZ0V4cCwgY29tbWVudFJlcGxhY2UpXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShjanNSZXF1aXJlUmVnRXhwLCBmdW5jdGlvbiAobWF0Y2gsIGRlcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vTWF5IGJlIGEgQ29tbW9uSlMgdGhpbmcgZXZlbiB3aXRob3V0IHJlcXVpcmUgY2FsbHMsIGJ1dCBzdGlsbFxcbiAgICAgICAgICAgICAgICAvL2NvdWxkIHVzZSBleHBvcnRzLCBhbmQgbW9kdWxlLiBBdm9pZCBkb2luZyBleHBvcnRzIGFuZCBtb2R1bGVcXG4gICAgICAgICAgICAgICAgLy93b3JrIHRob3VnaCBpZiBpdCBqdXN0IG5lZWRzIHJlcXVpcmUuXFxuICAgICAgICAgICAgICAgIC8vUkVRVUlSRVMgdGhlIGZ1bmN0aW9uIHRvIGV4cGVjdCB0aGUgQ29tbW9uSlMgdmFyaWFibGVzIGluIHRoZVxcbiAgICAgICAgICAgICAgICAvL29yZGVyIGxpc3RlZCBiZWxvdy5cXG4gICAgICAgICAgICAgICAgZGVwcyA9IChjYWxsYmFjay5sZW5ndGggPT09IDEgPyBbJ3JlcXVpcmUnXSA6IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddKS5jb25jYXQoZGVwcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9JZiBpbiBJRSA2LTggYW5kIGhpdCBhbiBhbm9ueW1vdXMgZGVmaW5lKCkgY2FsbCwgZG8gdGhlIGludGVyYWN0aXZlXFxuICAgICAgICAvL3dvcmsuXFxuICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmUpIHtcXG4gICAgICAgICAgICBub2RlID0gY3VycmVudGx5QWRkaW5nU2NyaXB0IHx8IGdldEludGVyYWN0aXZlU2NyaXB0KCk7XFxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVxdWlyZW1vZHVsZScpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0c1tub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXF1aXJlY29udGV4dCcpXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL0Fsd2F5cyBzYXZlIG9mZiBldmFsdWF0aW5nIHRoZSBkZWYgY2FsbCB1bnRpbCB0aGUgc2NyaXB0IG9ubG9hZCBoYW5kbGVyLlxcbiAgICAgICAgLy9UaGlzIGFsbG93cyBtdWx0aXBsZSBtb2R1bGVzIHRvIGJlIGluIGEgZmlsZSB3aXRob3V0IHByZW1hdHVyZWx5XFxuICAgICAgICAvL3RyYWNpbmcgZGVwZW5kZW5jaWVzLCBhbmQgYWxsb3dzIGZvciBhbm9ueW1vdXMgbW9kdWxlIHN1cHBvcnQsXFxuICAgICAgICAvL3doZXJlIHRoZSBtb2R1bGUgbmFtZSBpcyBub3Qga25vd24gdW50aWwgdGhlIHNjcmlwdCBvbmxvYWQgZXZlbnRcXG4gICAgICAgIC8vb2NjdXJzLiBJZiBubyBjb250ZXh0LCB1c2UgdGhlIGdsb2JhbCBxdWV1ZSwgYW5kIGdldCBpdCBwcm9jZXNzZWRcXG4gICAgICAgIC8vaW4gdGhlIG9uc2NyaXB0IGxvYWQgY2FsbGJhY2suXFxuICAgICAgICBpZiAoY29udGV4dCkge1xcbiAgICAgICAgICAgIGNvbnRleHQuZGVmUXVldWUucHVzaChbbmFtZSwgZGVwcywgY2FsbGJhY2tdKTtcXG4gICAgICAgICAgICBjb250ZXh0LmRlZlF1ZXVlTWFwW25hbWVdID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZ2xvYmFsRGVmUXVldWUucHVzaChbbmFtZSwgZGVwcywgY2FsbGJhY2tdKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgZGVmaW5lLmFtZCA9IHtcXG4gICAgICAgIGpRdWVyeTogdHJ1ZVxcbiAgICB9O1xcbiAgICBcXG5cXHRyZXEuZXhlYyA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuICAgICAgICAvKmpzbGludCBldmlsOiB0cnVlICovXFxuICAgICAgICByZXR1cm4gZXZhbCh0ZXh0KTtcXG4gICAgfTtcXG5cXG4gICAgLy9TZXQgdXAgd2l0aCBjb25maWcgaW5mby5cXG4gICAgcmVxKGNmZyk7XFxuYGBgXFxu5Y+v5Lul55+l6YGT77yM6L+Z5LiA5q615Luj56CB5piv6Kej5p6Q5a6a5LmJ5piv5qih5Z2X5omA6ZyA55qE5L6d6LWW5pS+572uIGNvbnRleHQg55qE5qih5Z2X5a6a5LmJ6Zif5YiX5Lit44CC54S25ZCO5oiR5Lus5bCx6KaB6YCa6L+HIHJlcSDljrvmiafooYzliqDovb3kvp3otZbvvIzmiJHku6zmnaXnnIvnnIsgcmVxIOeahOWumuS5ieOAglxcbmBgYFxcbnJlcSA9IHJlcXVpcmVqcyA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgZXJyYmFjaywgb3B0aW9uYWwpIHtcXG5cXG4gICAgICAgIC8vRmluZCB0aGUgcmlnaHQgY29udGV4dCwgdXNlIGRlZmF1bHRcXG4gICAgICAgIHZhciBjb250ZXh0LCBjb25maWcsXFxuICAgICAgICAgICAgY29udGV4dE5hbWUgPSBkZWZDb250ZXh0TmFtZTtcXG5cXG4gICAgICAgIC8vIERldGVybWluZSBpZiBoYXZlIGNvbmZpZyBvYmplY3QgaW4gdGhlIGNhbGwuXFxuICAgICAgICBpZiAoIWlzQXJyYXkoZGVwcykgJiYgdHlwZW9mIGRlcHMgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgLy8gZGVwcyBpcyBhIGNvbmZpZyBvYmplY3RcXG4gICAgICAgICAgICBjb25maWcgPSBkZXBzO1xcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNhbGxiYWNrKSkge1xcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXFxuICAgICAgICAgICAgICAgIGRlcHMgPSBjYWxsYmFjaztcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJiYWNrO1xcbiAgICAgICAgICAgICAgICBlcnJiYWNrID0gb3B0aW9uYWw7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZGVwcyA9IFtdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmNvbnRleHQpIHtcXG4gICAgICAgICAgICBjb250ZXh0TmFtZSA9IGNvbmZpZy5jb250ZXh0O1xcbiAgICAgICAgfVxcbiAgICAgICBcXG4gICAgICAgIGlmIChjb25maWcpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmNvbmZpZ3VyZShjb25maWcpOyAvLyDlrozlloTphY3nva5cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlcXVpcmUoZGVwcywgY2FsbGJhY2ssIGVycmJhY2spOyBcXG5gYGBcXG7ov5nph4znmoTku6PnoIHmioog5L6d6LWW77yM5Zue6LCD77yMIOmUmeivr+WkhOeQhuWSjOmFjee9rumhuemDveS8oOi/m+adpeS6hu+8jOi/m+ihjOS6humFjee9ruS4iueahOWkhOeQhuS5i+WQju+8jOaIkeS7rOWPr+S7peeci+WIsOacgOWQjuWGjeWOu+agueaNrumFjee9ruWKoOi9veOAglxcbuaIkeS7rOWGjeadpeeciyBjb250ZXh0LnJlcXVpcmUg5pa55rOVXFxuYGBgXFxubWFrZVJlcXVpcmU6IGZ1bmN0aW9uIChyZWxNYXAsIG9wdGlvbnMpIHtcXG5cXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRcXHRmdW5jdGlvbiBsb2NhbFJlcXVpcmUoZGVwcywgY2FsbGJhY2ssIGVycmJhY2spIHtcXG5cXHRcXHRcXHQuLi4uIOW9k+WJjSByZXF1aXJlIOeahOi9rOaNolxcbiAgICAgIFxcdCBcXHRyZXR1cm4gbG9jYWxSZXF1aXJlO1xcbiAgXFx0XFx0IH1cXG5cXHRcXHRjb21wbGV0ZUxvYWQ6IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XFxuXFx0XFx0XFx05Yik5patIGNvbnRleHQg55qE5L6d6LWW6Zif5YiX77yM5piv57un57ut5Yqg6L296L+Y5piv5omn6KGM5Zue6LCDXFxuXFx0XFx0fVxcblxcdFxcdCBuYW1lVG9Vcmw6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBleHQsIHNraXBFeHQpIHtcXG5cXHRcXHQgXFx05qC55o2u5qih5Z2X5ZCN5ZKM6YWN572u5b6X5Yiw5Yqg6L2955qE6Lev5b6EXFxuXFx0XFx0IH1cXG5cXHRcXHQgbG9hZDogZnVuY3Rpb24gKGlkLCB1cmwpIHtcXG5cXHQgICAgICAgICAgICAgICByZXEubG9hZChjb250ZXh0LCBpZCwgdXJsKTtcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIGV4ZWNDYjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBhcmdzLCBleHBvcnRzKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShleHBvcnRzLCBhcmdzKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0XFx0b25TY3JpcHRMb2FkOiBmdW5jdGlvbiAoZXZ0KSB7XFxuXFx0XFx0XFx06ISa5pys5Yqg6L295a6M5oiQ5ZCO5b6X5Yiw5pWw5o2u77yM5omn6KGMIGNvbnRleHQuY29tcGxldGVMb2FkKGRhdGEuaWQpO1xcblxcdFxcdH1cXG5cXHRcXHRvblNjcmlwdEVycm9yOiBmdW5jdGlvbiAoZXZ0KSB7XFxuXFx0XFx0XFx05Yqg6L296ZSZ6K+v5omn6KGM6ZSZ6K+v5aSE55CGXFxuXFx0XFx0fVxcblxcdH07XFxuICAgY29udGV4dC5yZXF1aXJlID0gY29udGV4dC5tYWtlUmVxdWlyZSgpO1xcbmBgYFxcbumCo+aIkeS7rOefpemBk+WFtuWunuWwseaYr+WbtOedgOi/meivreazleeahOino+aekO+8jOi/m+ihjOS4gOezu+WIl+eahOiEmuacrOWKoOi9ve+8jOeEtuWQjuaJp+ihjOWbnuiwg+OAglxcblxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==