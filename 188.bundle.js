"use strict";(self.webpackChunkreact_wyz=self.webpackChunkreact_wyz||[]).push([[188],{188:(n,e,r)=>{r.r(e),r.d(e,{default:()=>t});const t="## learn typescript\n### 类型\n基本类型: \n```\nstring number bool \n```\n\n数组 `[]`:  \n```\nstring[]  number[]\n```\n\n元祖:  \n```\n[string, number]. 数组中有不同的数据类型\n```\n\n对象:\n```\n{ name: string; age: number }\n```\n\n函数：\n```\n(arg1: string, arg?: bool) => void\n```\n\nSymbol:  \n```\nlet symbol = Symbol(\"key\"); \n```\n\n空：\n```\nundefined   null\n```\n\n任何类型： \n```\nany\n```\n\n不存在的值： \n```\nnever\n```\n\n### 如何定义类型\n`type`  定义类型变量\n```\ntype Person = { name: string; age: number}\nts 使用 const person1：Person = { name: '22', age: 1};\n```\n\n`Interfaces` 声明 `对象` 类型的一种方法\n```\nInterface Person { name: string; age: number}\n```\n\n`extends` 类型继承于声明的类型\n```\ninterface a { name: string}\ninterface b extends a {\n\tage: number\n}\nb 的类型等于 { name: string; age: number }\n```\n\nin 判断属性是哪个类型中的\n```\ntype PersonListQuery = { user_ids: string[] }\ntype DogListQuery = { dog_ids: string[] }\n\nfunction getList(query: PersonListQuery | DogListQuery ) {\n\tif ('user_ids' in PersonListQuery) {\n\t \t// 这里可以推导出 query 类型是 PersonListQuery\n\t}\n}\n\n```\n\n\n### 类型组合\n\n`Required<T>` 将 T 中所有属性变成必选\n```\nRequired<{ a?: bool} > = { a: bool }\n```\n\n`Partial<T>` 将 T 中所有属性变成可选\n```\nPartial<{ a: bool }> = { a?: bool }\n```\n\n`Readonly<T>` 将 T 中所有属性变成只读，后续 ts 会检测该类型不允许修改\n```\nconst person2: Readonly<{name: string}> = {name: '22'}\nperson2.name = '33' //error\n```\n`Omit<T, keys>` 删除某些属性\n```\ninterface Person {\n  name: string;\n  age: number;\n}\n \ntype Name = Omit<Person, 'age'>;\nName 的类型定义为 { name: string }\n```\n\n`Pick<T, keys>` 选择类型中的某些属性\n```\ninterface Person {\n  name: string;\n  age: number;\n}\ntype Name = Pick<Person, 'name'>;\nName 的类型定义为 { name: string }\n```\n\n\n`Exclude<T, deleteT>` 删除类型 T 中 deleteT 的类型， 相当于 Omit, 第二个值可以是 keys ，也可以是一个类型变量\n```\ninterface Person {\n  name: string;\n  age: number;\n}\ntype Age = { age: number }\ntype Name = Exclude<Person, Age>\nName 的类型定义为 { name: string }\n```\n\n\n`Extract<T, U>` 提取 T 继承于的 U 类型\n```\ntype Person = {  name: string ; age: number } \ntype PersonDetail = { pet: any; phone: number } \ntype Name = { name: string }\ntype Name = Extract<Person | PersonDetail , Name>\n 将提取出含有 name 的类型 Person\n```\n\n\n`Parameters<function T>` 获取函数类型的函数类型\n```\ntype getName = (perpson: Person) => string;\ntype queryType = Parameters<getName>;\nqueryType  的类型定义为 Person\n```\n\n`ReturnType<function T>` 获取函数类型的返回值类型\n```\ntype getName = (perpson: Person) => string;\ntype resType = ReturnType<getName>;\nvalueType 类型为 string\n```\n\n`Awaited<Promise Type>` 获取异步返回的值类型\n```\ntype getPerson = (id: string) => Promise<Person>\ntype resType = ReturnType<getPerson> // Promise<Person>\ntype valueType = Awaited<resType> // Person\n```\n\n`Record<K extends keyof any, T>`  定义对象的 key 键类型\n```\ntype Keys = 'name' | 'age' \ntype person = Record<Keys, any>\n// person 的属性只能为 name 和 age\n```\n\n`NonNullable<T>` 去除类型中定义的 null 和 undefined \n```\ntype PersonHobby = hobby: string | undefined;\ntype Hobby = NonNullable<hobby>\nHobby 类型为  string\n```\n\n### 类型操作\n\n`typeof Object` 获得`对象`的类型\n```\nconst person1 = { name: '22', age: 1}\ntype Person = typeof person1\nPerson 类型为 { name: string; age: number }\n```\n\n`keyof T`  获得类型中的属性\n```\ntype Person = { name: string; age: number }\ntype Key = keyof Person \nkey 的类型为 'name' | 'age'\n```\n通常我们可以通过 keyof 约束对象的传参， 如\n```\ntype Person = { name: string; age: number }\ntype Key = keyof Person;\ntype getPersonAtrribute = (person: Person, key: Key) => Person[Key];\n```\n或者某些情况下我们想知道一个对象的属性值 \n```\nconst workPerson = { \n\t'1': { name: '1', age: 1},\n\t'2': { name: '2', age: 2},\n}\ntype WorkPerson  = typeof workPerson;  // { '1': {name: string; age: number }, '2': {name: string; age: number }\ntype Key = keyof WorkPerson  // '1' | '2'\ntype Person = WorkPerson[Key]   // {name: string; age: number }\n```\n `|` 类型兼容\n```\ntype width = 'string' | 'number';\n\n则 width 可以是 '32px' 也可以是 '32' 在 渲染时兼容两种类型\n```\n\n\n### 函数重载\n\n定义不同类型的输入，推到出不同类型的输出\n\n```\ntype PersonListQuery = { user_ids: string[] };\ntype DongListQuery = { dog_ids: string[] };\nfunction getList(request: PersonListQuery): Person[];\nfunction getList(request: DogListQuery): Dog[];\n\nfunction getList(query: PersonListQuery | DogListQuery) {\n  if ('user_ids' in query) {  \n    return [] as Person[];\n  } else {\n    return [] as Dog[];\n  }\n}\n\nconst a = getList({ personIds: [], region: 'us'})\n此时 a 的类型将能推到出是 Person[]\n```\n\n### 泛型\n类型的传参。 用 T 标识，在实际运用时你传入什么类型，该类型就作为后续推导。\n```\nasync function request<T>(url: string): Promise<T> {\n  const res = await fetch(url)\n  return res.json();\n}\n\nconst res = await request<Person>('getPersonInfo?id=1'); \n此时 ts 可以推导出 res 的类型是 Person\n```\n\n### Infer  类型参数使用\n通过 Infer 一个类型为变量，定义出获取类型的方法\n```\ntype addResultType<T> = T extends { a: infer U, b: infer U } ?  U : never;\ntype numberAdd =  addResultType<{ a: 1, b: 2 }>     // 推到出结果类型为 number\ntype textAdd = addResultType<{ a: 'hello', b: 'world' }>     // 推到出结果类型为 string\n```\n\n\n### 枚举 enum\n变量的值是约定的几个取值\n\n```\nconst enum PageType {\n  HOME = 'home',\n  VIDEO = 'video',\n}\n\nfunction getPageUrl(page: PageType) {\n  return {\n    [PageType.VIDEO]: \"/video\",\n    [PageType.HOME]: \"/home\",\n  }[page];\n}\n```\n\n\n## tsconfig\n了解了 ts 对于类型的定义和各种规则后，我们则可以在编写 js 代码时利用并进行类型约束。于此同时，我们需要引入 typescript 库去获得这些 ts 能力。\n\n### 如何引入\n```\nnpm install  typescript  \n// 不必再多说\n```\n\n### 命令\ntypescript 包是有命令文件的，通常 ts 的运行则是通过 tsc 配合相关命令去执行的. 具体命令大家可以安装包之后通过 tsc -h 查看\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/349ffc362f0d831a780d2d7f754893a1.png)\n\n### 配置 [官网](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n如果你看了 tsc 命令，你会发现它是有很多命令的，并且有的命令还伴随这相关参数。在工作文件夹中，我们则通过配置文件 `tsconfig.js ` 去配置，保证在项目中的运用。 配置参数这里就不细讲了，还是看官方文档靠谱点。\n"}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4LmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoia0lBQUEsdW1MIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3Rfd3l6Ly4uLy4uL2Jsb2dzL21hcmtkb3duL3R5cGVzY3JpcHQubWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjIyBsZWFybiB0eXBlc2NyaXB0XFxuIyMjIOexu+Wei1xcbuWfuuacrOexu+WeizogXFxuYGBgXFxuc3RyaW5nIG51bWJlciBib29sIFxcbmBgYFxcblxcbuaVsOe7hCBgW11gOiAgXFxuYGBgXFxuc3RyaW5nW10gIG51bWJlcltdXFxuYGBgXFxuXFxu5YWD56WWOiAgXFxuYGBgXFxuW3N0cmluZywgbnVtYmVyXS4g5pWw57uE5Lit5pyJ5LiN5ZCM55qE5pWw5o2u57G75Z6LXFxuYGBgXFxuXFxu5a+56LGhOlxcbmBgYFxcbnsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9XFxuYGBgXFxuXFxu5Ye95pWw77yaXFxuYGBgXFxuKGFyZzE6IHN0cmluZywgYXJnPzogYm9vbCkgPT4gdm9pZFxcbmBgYFxcblxcblN5bWJvbDogIFxcbmBgYFxcbmxldCBzeW1ib2wgPSBTeW1ib2woXFxcImtleVxcXCIpOyBcXG5gYGBcXG5cXG7nqbrvvJpcXG5gYGBcXG51bmRlZmluZWQgICBudWxsXFxuYGBgXFxuXFxu5Lu75L2V57G75Z6L77yaIFxcbmBgYFxcbmFueVxcbmBgYFxcblxcbuS4jeWtmOWcqOeahOWAvO+8miBcXG5gYGBcXG5uZXZlclxcbmBgYFxcblxcbiMjIyDlpoLkvZXlrprkuYnnsbvlnotcXG5gdHlwZWAgIOWumuS5ieexu+Wei+WPmOmHj1xcbmBgYFxcbnR5cGUgUGVyc29uID0geyBuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyfVxcbnRzIOS9v+eUqCBjb25zdCBwZXJzb24x77yaUGVyc29uID0geyBuYW1lOiAnMjInLCBhZ2U6IDF9O1xcbmBgYFxcblxcbmBJbnRlcmZhY2VzYCDlo7DmmI4gYOWvueixoWAg57G75Z6L55qE5LiA56eN5pa55rOVXFxuYGBgXFxuSW50ZXJmYWNlIFBlcnNvbiB7IG5hbWU6IHN0cmluZzsgYWdlOiBudW1iZXJ9XFxuYGBgXFxuXFxuYGV4dGVuZHNgIOexu+Wei+e7p+aJv+S6juWjsOaYjueahOexu+Wei1xcbmBgYFxcbmludGVyZmFjZSBhIHsgbmFtZTogc3RyaW5nfVxcbmludGVyZmFjZSBiIGV4dGVuZHMgYSB7XFxuXFx0YWdlOiBudW1iZXJcXG59XFxuYiDnmoTnsbvlnovnrYnkuo4geyBuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyIH1cXG5gYGBcXG5cXG5pbiDliKTmlq3lsZ7mgKfmmK/lk6rkuKrnsbvlnovkuK3nmoRcXG5gYGBcXG50eXBlIFBlcnNvbkxpc3RRdWVyeSA9IHsgdXNlcl9pZHM6IHN0cmluZ1tdIH1cXG50eXBlIERvZ0xpc3RRdWVyeSA9IHsgZG9nX2lkczogc3RyaW5nW10gfVxcblxcbmZ1bmN0aW9uIGdldExpc3QocXVlcnk6IFBlcnNvbkxpc3RRdWVyeSB8IERvZ0xpc3RRdWVyeSApIHtcXG5cXHRpZiAoJ3VzZXJfaWRzJyBpbiBQZXJzb25MaXN0UXVlcnkpIHtcXG5cXHQgXFx0Ly8g6L+Z6YeM5Y+v5Lul5o6o5a+85Ye6IHF1ZXJ5IOexu+Wei+aYryBQZXJzb25MaXN0UXVlcnlcXG5cXHR9XFxufVxcblxcbmBgYFxcblxcblxcbiMjIyDnsbvlnovnu4TlkIhcXG5cXG5gUmVxdWlyZWQ8VD5gIOWwhiBUIOS4reaJgOacieWxnuaAp+WPmOaIkOW/hemAiVxcbmBgYFxcblJlcXVpcmVkPHsgYT86IGJvb2x9ID4gPSB7IGE6IGJvb2wgfVxcbmBgYFxcblxcbmBQYXJ0aWFsPFQ+YCDlsIYgVCDkuK3miYDmnInlsZ7mgKflj5jmiJDlj6/pgIlcXG5gYGBcXG5QYXJ0aWFsPHsgYTogYm9vbCB9PiA9IHsgYT86IGJvb2wgfVxcbmBgYFxcblxcbmBSZWFkb25seTxUPmAg5bCGIFQg5Lit5omA5pyJ5bGe5oCn5Y+Y5oiQ5Y+q6K+777yM5ZCO57utIHRzIOS8muajgOa1i+ivpeexu+Wei+S4jeWFgeiuuOS/ruaUuVxcbmBgYFxcbmNvbnN0IHBlcnNvbjI6IFJlYWRvbmx5PHtuYW1lOiBzdHJpbmd9PiA9IHtuYW1lOiAnMjInfVxcbnBlcnNvbjIubmFtZSA9ICczMycgLy9lcnJvclxcbmBgYFxcbmBPbWl0PFQsIGtleXM+YCDliKDpmaTmn5DkupvlsZ7mgKdcXG5gYGBcXG5pbnRlcmZhY2UgUGVyc29uIHtcXG4gIG5hbWU6IHN0cmluZztcXG4gIGFnZTogbnVtYmVyO1xcbn1cXG4gXFxudHlwZSBOYW1lID0gT21pdDxQZXJzb24sICdhZ2UnPjtcXG5OYW1lIOeahOexu+Wei+WumuS5ieS4uiB7IG5hbWU6IHN0cmluZyB9XFxuYGBgXFxuXFxuYFBpY2s8VCwga2V5cz5gIOmAieaLqeexu+Wei+S4reeahOafkOS6m+WxnuaAp1xcbmBgYFxcbmludGVyZmFjZSBQZXJzb24ge1xcbiAgbmFtZTogc3RyaW5nO1xcbiAgYWdlOiBudW1iZXI7XFxufVxcbnR5cGUgTmFtZSA9IFBpY2s8UGVyc29uLCAnbmFtZSc+O1xcbk5hbWUg55qE57G75Z6L5a6a5LmJ5Li6IHsgbmFtZTogc3RyaW5nIH1cXG5gYGBcXG5cXG5cXG5gRXhjbHVkZTxULCBkZWxldGVUPmAg5Yig6Zmk57G75Z6LIFQg5LitIGRlbGV0ZVQg55qE57G75Z6L77yMIOebuOW9k+S6jiBPbWl0LCDnrKzkuozkuKrlgLzlj6/ku6XmmK8ga2V5cyDvvIzkuZ/lj6/ku6XmmK/kuIDkuKrnsbvlnovlj5jph49cXG5gYGBcXG5pbnRlcmZhY2UgUGVyc29uIHtcXG4gIG5hbWU6IHN0cmluZztcXG4gIGFnZTogbnVtYmVyO1xcbn1cXG50eXBlIEFnZSA9IHsgYWdlOiBudW1iZXIgfVxcbnR5cGUgTmFtZSA9IEV4Y2x1ZGU8UGVyc29uLCBBZ2U+XFxuTmFtZSDnmoTnsbvlnovlrprkuYnkuLogeyBuYW1lOiBzdHJpbmcgfVxcbmBgYFxcblxcblxcbmBFeHRyYWN0PFQsIFU+YCDmj5Dlj5YgVCDnu6fmib/kuo7nmoQgVSDnsbvlnotcXG5gYGBcXG50eXBlIFBlcnNvbiA9IHsgIG5hbWU6IHN0cmluZyA7IGFnZTogbnVtYmVyIH0gXFxudHlwZSBQZXJzb25EZXRhaWwgPSB7IHBldDogYW55OyBwaG9uZTogbnVtYmVyIH0gXFxudHlwZSBOYW1lID0geyBuYW1lOiBzdHJpbmcgfVxcbnR5cGUgTmFtZSA9IEV4dHJhY3Q8UGVyc29uIHwgUGVyc29uRGV0YWlsICwgTmFtZT5cXG4g5bCG5o+Q5Y+W5Ye65ZCr5pyJIG5hbWUg55qE57G75Z6LIFBlcnNvblxcbmBgYFxcblxcblxcbmBQYXJhbWV0ZXJzPGZ1bmN0aW9uIFQ+YCDojrflj5blh73mlbDnsbvlnovnmoTlh73mlbDnsbvlnotcXG5gYGBcXG50eXBlIGdldE5hbWUgPSAocGVycHNvbjogUGVyc29uKSA9PiBzdHJpbmc7XFxudHlwZSBxdWVyeVR5cGUgPSBQYXJhbWV0ZXJzPGdldE5hbWU+O1xcbnF1ZXJ5VHlwZSAg55qE57G75Z6L5a6a5LmJ5Li6IFBlcnNvblxcbmBgYFxcblxcbmBSZXR1cm5UeXBlPGZ1bmN0aW9uIFQ+YCDojrflj5blh73mlbDnsbvlnovnmoTov5Tlm57lgLznsbvlnotcXG5gYGBcXG50eXBlIGdldE5hbWUgPSAocGVycHNvbjogUGVyc29uKSA9PiBzdHJpbmc7XFxudHlwZSByZXNUeXBlID0gUmV0dXJuVHlwZTxnZXROYW1lPjtcXG52YWx1ZVR5cGUg57G75Z6L5Li6IHN0cmluZ1xcbmBgYFxcblxcbmBBd2FpdGVkPFByb21pc2UgVHlwZT5gIOiOt+WPluW8guatpei/lOWbnueahOWAvOexu+Wei1xcbmBgYFxcbnR5cGUgZ2V0UGVyc29uID0gKGlkOiBzdHJpbmcpID0+IFByb21pc2U8UGVyc29uPlxcbnR5cGUgcmVzVHlwZSA9IFJldHVyblR5cGU8Z2V0UGVyc29uPiAvLyBQcm9taXNlPFBlcnNvbj5cXG50eXBlIHZhbHVlVHlwZSA9IEF3YWl0ZWQ8cmVzVHlwZT4gLy8gUGVyc29uXFxuYGBgXFxuXFxuYFJlY29yZDxLIGV4dGVuZHMga2V5b2YgYW55LCBUPmAgIOWumuS5ieWvueixoeeahCBrZXkg6ZSu57G75Z6LXFxuYGBgXFxudHlwZSBLZXlzID0gJ25hbWUnIHwgJ2FnZScgXFxudHlwZSBwZXJzb24gPSBSZWNvcmQ8S2V5cywgYW55Plxcbi8vIHBlcnNvbiDnmoTlsZ7mgKflj6rog73kuLogbmFtZSDlkowgYWdlXFxuYGBgXFxuXFxuYE5vbk51bGxhYmxlPFQ+YCDljrvpmaTnsbvlnovkuK3lrprkuYnnmoQgbnVsbCDlkowgdW5kZWZpbmVkIFxcbmBgYFxcbnR5cGUgUGVyc29uSG9iYnkgPSBob2JieTogc3RyaW5nIHwgdW5kZWZpbmVkO1xcbnR5cGUgSG9iYnkgPSBOb25OdWxsYWJsZTxob2JieT5cXG5Ib2JieSDnsbvlnovkuLogIHN0cmluZ1xcbmBgYFxcblxcbiMjIyDnsbvlnovmk43kvZxcXG5cXG5gdHlwZW9mIE9iamVjdGAg6I635b6XYOWvueixoWDnmoTnsbvlnotcXG5gYGBcXG5jb25zdCBwZXJzb24xID0geyBuYW1lOiAnMjInLCBhZ2U6IDF9XFxudHlwZSBQZXJzb24gPSB0eXBlb2YgcGVyc29uMVxcblBlcnNvbiDnsbvlnovkuLogeyBuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyIH1cXG5gYGBcXG5cXG5ga2V5b2YgVGAgIOiOt+W+l+exu+Wei+S4reeahOWxnuaAp1xcbmBgYFxcbnR5cGUgUGVyc29uID0geyBuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyIH1cXG50eXBlIEtleSA9IGtleW9mIFBlcnNvbiBcXG5rZXkg55qE57G75Z6L5Li6ICduYW1lJyB8ICdhZ2UnXFxuYGBgXFxu6YCa5bi45oiR5Lus5Y+v5Lul6YCa6L+HIGtleW9mIOe6puadn+WvueixoeeahOS8oOWPgu+8jCDlpoJcXG5gYGBcXG50eXBlIFBlcnNvbiA9IHsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9XFxudHlwZSBLZXkgPSBrZXlvZiBQZXJzb247XFxudHlwZSBnZXRQZXJzb25BdHJyaWJ1dGUgPSAocGVyc29uOiBQZXJzb24sIGtleTogS2V5KSA9PiBQZXJzb25bS2V5XTtcXG5gYGBcXG7miJbogIXmn5Dkupvmg4XlhrXkuIvmiJHku6zmg7Pnn6XpgZPkuIDkuKrlr7nosaHnmoTlsZ7mgKflgLwgXFxuYGBgXFxuY29uc3Qgd29ya1BlcnNvbiA9IHsgXFxuXFx0JzEnOiB7IG5hbWU6ICcxJywgYWdlOiAxfSxcXG5cXHQnMic6IHsgbmFtZTogJzInLCBhZ2U6IDJ9LFxcbn1cXG50eXBlIFdvcmtQZXJzb24gID0gdHlwZW9mIHdvcmtQZXJzb247ICAvLyB7ICcxJzoge25hbWU6IHN0cmluZzsgYWdlOiBudW1iZXIgfSwgJzInOiB7bmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9XFxudHlwZSBLZXkgPSBrZXlvZiBXb3JrUGVyc29uICAvLyAnMScgfCAnMidcXG50eXBlIFBlcnNvbiA9IFdvcmtQZXJzb25bS2V5XSAgIC8vIHtuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyIH1cXG5gYGBcXG4gYHxgIOexu+Wei+WFvOWuuVxcbmBgYFxcbnR5cGUgd2lkdGggPSAnc3RyaW5nJyB8ICdudW1iZXInO1xcblxcbuWImSB3aWR0aCDlj6/ku6XmmK8gJzMycHgnIOS5n+WPr+S7peaYryAnMzInIOWcqCDmuLLmn5Pml7blhbzlrrnkuKTnp43nsbvlnotcXG5gYGBcXG5cXG5cXG4jIyMg5Ye95pWw6YeN6L29XFxuXFxu5a6a5LmJ5LiN5ZCM57G75Z6L55qE6L6T5YWl77yM5o6o5Yiw5Ye65LiN5ZCM57G75Z6L55qE6L6T5Ye6XFxuXFxuYGBgXFxudHlwZSBQZXJzb25MaXN0UXVlcnkgPSB7IHVzZXJfaWRzOiBzdHJpbmdbXSB9O1xcbnR5cGUgRG9uZ0xpc3RRdWVyeSA9IHsgZG9nX2lkczogc3RyaW5nW10gfTtcXG5mdW5jdGlvbiBnZXRMaXN0KHJlcXVlc3Q6IFBlcnNvbkxpc3RRdWVyeSk6IFBlcnNvbltdO1xcbmZ1bmN0aW9uIGdldExpc3QocmVxdWVzdDogRG9nTGlzdFF1ZXJ5KTogRG9nW107XFxuXFxuZnVuY3Rpb24gZ2V0TGlzdChxdWVyeTogUGVyc29uTGlzdFF1ZXJ5IHwgRG9nTGlzdFF1ZXJ5KSB7XFxuICBpZiAoJ3VzZXJfaWRzJyBpbiBxdWVyeSkgeyAgXFxuICAgIHJldHVybiBbXSBhcyBQZXJzb25bXTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBbXSBhcyBEb2dbXTtcXG4gIH1cXG59XFxuXFxuY29uc3QgYSA9IGdldExpc3QoeyBwZXJzb25JZHM6IFtdLCByZWdpb246ICd1cyd9KVxcbuatpOaXtiBhIOeahOexu+Wei+WwhuiDveaOqOWIsOWHuuaYryBQZXJzb25bXVxcbmBgYFxcblxcbiMjIyDms5vlnotcXG7nsbvlnovnmoTkvKDlj4LjgIIg55SoIFQg5qCH6K+G77yM5Zyo5a6e6ZmF6L+Q55So5pe25L2g5Lyg5YWl5LuA5LmI57G75Z6L77yM6K+l57G75Z6L5bCx5L2c5Li65ZCO57ut5o6o5a+844CCXFxuYGBgXFxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4ge1xcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKVxcbiAgcmV0dXJuIHJlcy5qc29uKCk7XFxufVxcblxcbmNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3Q8UGVyc29uPignZ2V0UGVyc29uSW5mbz9pZD0xJyk7IFxcbuatpOaXtiB0cyDlj6/ku6Xmjqjlr7zlh7ogcmVzIOeahOexu+Wei+aYryBQZXJzb25cXG5gYGBcXG5cXG4jIyMgSW5mZXIgIOexu+Wei+WPguaVsOS9v+eUqFxcbumAmui/hyBJbmZlciDkuIDkuKrnsbvlnovkuLrlj5jph4/vvIzlrprkuYnlh7rojrflj5bnsbvlnovnmoTmlrnms5VcXG5gYGBcXG50eXBlIGFkZFJlc3VsdFR5cGU8VD4gPSBUIGV4dGVuZHMgeyBhOiBpbmZlciBVLCBiOiBpbmZlciBVIH0gPyAgVSA6IG5ldmVyO1xcbnR5cGUgbnVtYmVyQWRkID0gIGFkZFJlc3VsdFR5cGU8eyBhOiAxLCBiOiAyIH0+ICAgICAvLyDmjqjliLDlh7rnu5PmnpznsbvlnovkuLogbnVtYmVyXFxudHlwZSB0ZXh0QWRkID0gYWRkUmVzdWx0VHlwZTx7IGE6ICdoZWxsbycsIGI6ICd3b3JsZCcgfT4gICAgIC8vIOaOqOWIsOWHuue7k+aenOexu+Wei+S4uiBzdHJpbmdcXG5gYGBcXG5cXG5cXG4jIyMg5p6a5Li+IGVudW1cXG7lj5jph4/nmoTlgLzmmK/nuqblrprnmoTlh6DkuKrlj5blgLxcXG5cXG5gYGBcXG5jb25zdCBlbnVtIFBhZ2VUeXBlIHtcXG4gIEhPTUUgPSAnaG9tZScsXFxuICBWSURFTyA9ICd2aWRlbycsXFxufVxcblxcbmZ1bmN0aW9uIGdldFBhZ2VVcmwocGFnZTogUGFnZVR5cGUpIHtcXG4gIHJldHVybiB7XFxuICAgIFtQYWdlVHlwZS5WSURFT106IFxcXCIvdmlkZW9cXFwiLFxcbiAgICBbUGFnZVR5cGUuSE9NRV06IFxcXCIvaG9tZVxcXCIsXFxuICB9W3BhZ2VdO1xcbn1cXG5gYGBcXG5cXG5cXG4jIyB0c2NvbmZpZ1xcbuS6huino+S6hiB0cyDlr7nkuo7nsbvlnovnmoTlrprkuYnlkozlkITnp43op4TliJnlkI7vvIzmiJHku6zliJnlj6/ku6XlnKjnvJblhpkganMg5Luj56CB5pe25Yip55So5bm26L+b6KGM57G75Z6L57qm5p2f44CC5LqO5q2k5ZCM5pe277yM5oiR5Lus6ZyA6KaB5byV5YWlIHR5cGVzY3JpcHQg5bqT5Y676I635b6X6L+Z5LqbIHRzIOiDveWKm+OAglxcblxcbiMjIyDlpoLkvZXlvJXlhaVcXG5gYGBcXG5ucG0gaW5zdGFsbCAgdHlwZXNjcmlwdCAgXFxuLy8g5LiN5b+F5YaN5aSa6K+0XFxuYGBgXFxuXFxuIyMjIOWRveS7pFxcbnR5cGVzY3JpcHQg5YyF5piv5pyJ5ZG95Luk5paH5Lu255qE77yM6YCa5bi4IHRzIOeahOi/kOihjOWImeaYr+mAmui/hyB0c2Mg6YWN5ZCI55u45YWz5ZG95Luk5Y675omn6KGM55qELiDlhbfkvZPlkb3ku6TlpKflrrblj6/ku6Xlronoo4XljIXkuYvlkI7pgJrov4cgdHNjIC1oIOafpeeci1xcbiFb5Zyo6L+Z6YeM5o+S5YWl5Zu+54mH5o+P6L+wXShodHRwczovL2ktYmxvZy5jc2RuaW1nLmNuL2Jsb2dfbWlncmF0ZS8zNDlmZmMzNjJmMGQ4MzFhNzgwZDJkN2Y3NTQ4OTNhMS5wbmcpXFxuXFxuIyMjIOmFjee9riBb5a6Y572RXShodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay90c2NvbmZpZy1qc29uLmh0bWwpXFxu5aaC5p6c5L2g55yL5LqGIHRzYyDlkb3ku6TvvIzkvaDkvJrlj5HnjrDlroPmmK/mnInlvojlpJrlkb3ku6TnmoTvvIzlubbkuJTmnInnmoTlkb3ku6Tov5jkvLTpmo/ov5nnm7jlhbPlj4LmlbDjgILlnKjlt6XkvZzmlofku7blpLnkuK3vvIzmiJHku6zliJnpgJrov4fphY3nva7mlofku7YgYHRzY29uZmlnLmpzIGAg5Y676YWN572u77yM5L+d6K+B5Zyo6aG555uu5Lit55qE6L+Q55So44CCIOmFjee9ruWPguaVsOi/memHjOWwseS4jee7huiusuS6hu+8jOi/mOaYr+eci+WumOaWueaWh+aho+mdoOiwseeCueOAglxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==