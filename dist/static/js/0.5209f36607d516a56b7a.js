webpackJsonp([0],Array(79).concat([function(e,t,n){function r(e){return n(s(e))}function s(e){var t=v[e];if(!(t+1))throw new Error("Cannot find module '"+e+"'.");return t}var v={"./aliyun-server.md":118,"./bem.md":119,"./canvas-svg.md":120,"./code-format.md":121,"./module.md":122,"./postcss-plugin.md":123,"./pwa.md":124,"./readme.md":125,"./safe.md":126,"./ssl.md":127,"./typescript.md":128,"./vue.md":129,"./webpack.md":130};r.keys=function(){return Object.keys(v)},r.resolve=s,e.exports=r,r.id=79},,,,,,,,,function(e,t,n){var r=n(7)(null,n(108),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(111),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(109),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(104),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(113),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(103),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(116),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(112),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(110),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(115),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(105),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(114),null,null,null);e.exports=r.exports},function(e,t,n){var r=n(7)(null,n(107),null,null,null);e.exports=r.exports},,,function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h2",{attrs:{id:"%E5%86%99-css-%E9%81%87%E5%88%B0%E4%BA%86%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"}},[e._v("写 css 遇到了问题怎么办？")]),e._v(" "),n("h3",{attrs:{id:"%E5%A6%82%E4%BD%95%E8%AE%A9-css-%E5%86%99%E7%9A%84%E6%9B%B4%E8%BD%BB%E6%9D%BE%EF%BC%9F"}},[e._v("如何让 css 写的更轻松？")]),e._v(" "),n("h4",{attrs:{id:"postcss-ui-theme%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%AE%9E%E7%8E%B0%E7%B1%BB-sass-%E8%AF%AD%E6%B3%95%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E5%B0%B1%E8%83%BD%E5%81%9A%E5%88%B0%EF%BC%81"}},[n("a",{attrs:{href:"https://github.com/cleverboy32/postcss-ui-theme"}},[e._v("postcss-ui-theme")]),e._v("，让你实现类 sass 语法，一个插件就能做到！")]),e._v(" "),n("h3",{attrs:{id:"%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98-css-%E4%B8%BB%E9%A2%98-%EF%BC%9F"}},[e._v("如何改变 css 主题 ？")]),e._v(" "),n("h4",{attrs:{id:"postcss-ui-theme-%EF%BC%8C-%E5%8F%AF%E6%89%93%E5%8C%85-css4-%E5%8F%98%E9%87%8F%E8%A2%AB%E4%BF%9D%E7%95%99%EF%BC%8C%E4%B8%8D%E4%BB%85%E5%8F%AF%E5%9C%A8%E5%BC%95%E7%94%A8%E6%97%B6%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%94%B9%E5%8F%98%E4%B8%BB%E9%A2%98%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-js-%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%94%B9%EF%BC%81%EF%BC%81%EF%BC%81"}},[n("a",{attrs:{href:"https://github.com/cleverboy32/postcss-ui-theme"}},[e._v("postcss-ui-theme ")]),e._v("， 可打包 css4 变量被保留，不仅可在引用时直接使用新的变量文件覆盖改变主题，还可以通过 js 进行更改！！！")]),e._v(" "),n("h3",{attrs:{id:"css-%E5%9C%A8%E5%88%AB%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%A2%AB%E7%BC%96%E8%AF%91%EF%BC%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%89%BE%E4%B8%8D%E5%88%B0%EF%BC%9F"}},[e._v("css 在别的项目被编译，文件路径找不到？")]),e._v(" "),n("h4",{attrs:{id:"postcss-ui-theme%EF%BC%8C-%E9%9B%86%E6%88%90-postcss-assets-%E6%8F%92%E4%BB%B6%EF%BC%8C%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81"}},[n("a",{attrs:{href:"https://github.com/cleverboy32/postcss-ui-theme"}},[e._v("postcss-ui-theme")]),e._v("， 集成 postcss-assets 插件，通过配置 文件查找路径，解决引用文件找不到问题！！")]),e._v(" "),n("h3",{attrs:{id:"postcss-ui-theme-%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%BD%A0%E7%9A%84-css-%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E7%9A%84%E6%9C%80%E4%BD%B3%E9%80%89%E6%8B%A9!-%E7%82%B9-star-%E6%94%B6%E8%97%8F%EF%BC%81%EF%BC%81%EF%BC%81-%E8%8C%AB%E8%8C%AB%E5%89%8D%E7%AB%AF%E8%B7%AF%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%83%E7%9A%84%EF%BC%81"}},[n("a",{attrs:{href:"https://github.com/cleverboy32/postcss-ui-theme"}},[e._v("postcss-ui-theme")]),e._v(" 插件，就是你的 css 管理方案的最佳选择! 点 star 收藏！！！ 茫茫前端路，你真的会用到它的！")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("作为一个程序员，工作到现在，也将近半年了。公司对员工的代码提交也会有 review 流程。代码的 review 来讲，一般就是看格式、命名、逻辑是否有错，代码是否还有可以抽象的地方，这里总结一下自己遇到的代码规范方面的问题，大家一起写规范的代码，做一个看上去专业码农吧。")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("####"),n("strong",[e._v("js规范")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("代码的缩进了，一般是两格或四格，我司采用的是四格，这里可以根据自己喜好和公司要求了。")])]),e._v(" "),n("li",[n("p",[e._v("中英文之间有空格间隔，像这样: "),n("code",{pre:!0},[e._v("我专业引用 English 单词")])])]),e._v(" "),n("li",[n("p",[e._v("命名规范，命名的驼峰式不用再说了。这里具体情况具体分析一下")]),e._v(" "),n("ul",[n("li",[e._v("变量的命名：小驼峰式")]),e._v(" "),n("li",[e._v("函数的命名：小驼峰式")]),e._v(" "),n("li",[e._v("常量：全部大写")]),e._v(" "),n("li",[e._v("构造函数： 大驼峰式")]),e._v(" "),n("li",[e._v("类的成员： 公共属性和方法就是小驼峰式， 私有属性和方法加上"),n("code",{pre:!0},[e._v("-")]),e._v("前缀,然后是小驼峰式，如 `_nameFrist")])]),e._v(" "),n("hr")])]),e._v(" "),n("p",[e._v("####"),n("strong",[e._v("css规范")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("css 的基本命名,  自己刚写的时候以为也是写小驼峰式，后来就呵呵了。css 当中就是用 "),n("code",{pre:!0},[e._v("-")]),e._v(" 连接了， 如 "),n("code",{pre:!0},[e._v("search-button")]),e._v("，在定义 id 的时候是用小驼峰了。")])]),e._v(" "),n("li",[n("p",[e._v("css 名字意思定义。这里有一个 BEM 的命名法则参考，可以看看我之前写的一篇博客"),n("a",{attrs:{href:"http://blog.csdn.net/dadadeganhuo/article/details/76600264"}},[e._v("了解BEM")])])]),e._v(" "),n("li",[n("p",[e._v("css 命名的统一前缀， 在一个项目中，约定好同一个前缀，可避免样式的覆盖。")])]),e._v(" "),n("li",[n("p",[e._v("css 样式书写顺序：")]),e._v(" "),n("ul",[n("li",[e._v("显示属性：display/list-style/position/float/clear …")]),e._v(" "),n("li",[e._v("自身属性（盒模型）：width/height/margin/padding/border")]),e._v(" "),n("li",[e._v("背景：background")]),e._v(" "),n("li",[e._v("行高：line-height")]),e._v(" "),n("li",[e._v("文本属性：color/font/text-decoration/text-align/...")]),e._v(" "),n("li",[e._v("其他：cursor/z-index/zoom/overflow")]),e._v(" "),n("li",[e._v("CSS3属性：transform/transition/animation/box-shadow/border-radius")]),e._v(" "),n("li",[e._v("如果使用CSS3的属性，如果有必要加入浏览器前缀，则按照 -webkit- / -moz- / -ms- / -o- /"),n("br"),e._v("\nstd的顺序进行添加，标准属性写在最后。")]),e._v(" "),n("li",[e._v("链接的样式请严格按照如下顺序添加： a:link -> a:visited -> a:hover -> a:active")])])]),e._v(" "),n("li",[n("p",[e._v("代码优化，能合并的属性就合并写，没用的属性也删掉，避免重复样式，避免使用 "),n("code",{pre:!0},[e._v("!important")])])])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("####"),n("strong",[e._v("git commit log 规则")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("首先就是commit 内容的分类了，如图片所示："),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20170830144139403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}}),e._v("定好分类，分类后面可以加你本次修改具体文件，然后组织本次修改的内容，就写好了 commit log啦。比如："),n("code",{pre:!0},[e._v("feat(login): 新增登录验证功能")]),e._v(",这表达出了你再login文件上新增了一个验证的功能。编写正确的 log 信息，能够清楚的表述你写的代码目的。")])]),e._v(" "),n("li",[n("p",[e._v("commit 次数，这里我们每完成一个小点的时候，都可以 commit 一下，因为commit 是记录你完成一个项目的具体过程。")])])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("= = 之前没好好总结，今天写总结的时候，也去搜了搜别的文章，发现这样的文章其实挺多，自己以前都没怎么好好看看 = = 。"),n("br"),e._v("\n欢迎补充啊~")]),e._v(" "),n("p",[e._v("####参考")]),e._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://www.douban.com/note/499976405/?type=like"}},[e._v("前端人员必看的CSS规范")]),n("br"),e._v(" "),n("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"}},[e._v("Commit message 和 Change log 编写指南")])])])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h2",{attrs:{id:"learn-typescript"}},[e._v("learn typescript")]),e._v(" "),n("h3",{attrs:{id:"%E7%B1%BB%E5%9E%8B"}},[e._v("类型")]),e._v(" "),n("p",[e._v("基本类型: string number bool")]),e._v(" "),n("p",[e._v("数组 "),n("code",{pre:!0},[e._v("[]")]),e._v(":  string[]  number[]")]),e._v(" "),n("p",[e._v("元祖:  [string, number]. 数组中有不同的数据类型")]),e._v(" "),n("p",[e._v("对象: { name: string; age: number }")]),e._v(" "),n("p",[e._v("函数：(arg1: string, arg?: bool) => void")]),e._v(" "),n("p",[e._v('Symbol:  let symbol = Symbol("key");')]),e._v(" "),n("p",[e._v("空： undefined   null")]),e._v(" "),n("p",[e._v("任何类型： any")]),e._v(" "),n("p",[e._v("不存在的值： never")]),e._v(" "),n("h3",{attrs:{id:"%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"}},[e._v("如何定义类型")]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("type")]),e._v("  定义类型变量")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type Person = { name: string; age: number}\nts 使用 const person1：Person = { name: '22', age: 1};\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Interfaces")]),e._v(" 声明 "),n("code",{pre:!0},[e._v("对象")]),e._v(" 类型的一种方法")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Interface Person { name: string; age: number}\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("extends")]),e._v(" 类型继承于声明的类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("interface a { name: string}\ninterface b extends a {\n\tage: number\n}\nb 的类型等于 { name: string; age: number }\n")])]),e._v(" "),n("p",[e._v("in 判断属性是哪个类型中的")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type PersonListQuery = { user_ids: string[] }\ntype DogListQuery = { dog_ids: string[] }\n\nfunction getList(query: PersonListQuery | DogListQuery ) {\n\tif ('user_ids' in PersonListQuery) {\n\t \t// 这里可以推导出 query 类型是 PersonListQuery\n\t}\n}\n\n")])]),e._v(" "),n("h3",{attrs:{id:"%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%90%88"}},[e._v("类型组合")]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Required<T>")]),e._v(" 将 T 中所有属性变成必选")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Required<{ a?: bool} > = { a: bool }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Partial<T>")]),e._v(" 将 T 中所有属性变成可选")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Partial<{ a: bool }> = { a?: bool }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Readonly<T>")]),e._v(" 将 T 中所有属性变成只读，后续 ts 会检测该类型不允许修改")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const person2: Readonly<{name: string}> = {name: '22'}\nperson2.name = '33' //error\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Omit<T, keys>")]),e._v(" 删除某些属性")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("interface Person {\n  name: string;\n  age: number;\n}\n \ntype Name = Omit<Person, 'age'>;\nName 的类型定义为 { name: string }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Pick<T, keys>")]),e._v(" 选择类型中的某些属性")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("interface Person {\n  name: string;\n  age: number;\n}\ntype Name = Pick<Person, 'name'>;\nName 的类型定义为 { name: string }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Exclude<T, deleteT>")]),e._v(" 删除类型 T 中 deleteT 的类型， 相当于 Omit, 第二个值可以是 keys ，也可以是一个类型变量")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("interface Person {\n  name: string;\n  age: number;\n}\ntype Age = { age: number }\ntype Name = Exclude<Person, Age>\nName 的类型定义为 { name: string }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Extract<T, U>")]),e._v(" 提取 T 继承于的 U 类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type Person = {  name: string ; age: number } \ntype PersonDetail = { pet: any; phone: number } \ntype Name = { name: string }\ntype Name = Extract<Person | PersonDetail , Name>\n 将提取出含有 name 的类型 Person\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Parameters<function T>")]),e._v(" 获取函数类型的函数类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type getName = (perpson: Person) => string;\ntype queryType = Parameters<getName>;\nqueryType  的类型定义为 Person\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("ReturnType<function T>")]),e._v(" 获取函数类型的返回值类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type getName = (perpson: Person) => string;\ntype resType = ReturnType<getName>;\nvalueType 类型为 string\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Awaited<Promise Type>")]),e._v(" 获取异步返回的值类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type getPerson = (id: string) => Promise<Person>\ntype resType = ReturnType<getPerson> // Promise<Person>\ntype valueType = Awaited<resType> // Person\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Record<K extends keyof any, T>")]),e._v("  定义对象的 key 键类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type Keys = 'name' | 'age' \ntype person = Record<Keys, any>\n// person 的属性只能为 name 和 age\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("NonNullable<T>")]),e._v(" 去除类型中定义的 null 和 undefined")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type PersonHobby = hobby: string | undefined;\ntype Hobby = NonNullable<hobby>\nHobby 类型为  string\n")])]),e._v(" "),n("h3",{attrs:{id:"%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C"}},[e._v("类型操作")]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("typeof Object")]),e._v(" 获得"),n("code",{pre:!0},[e._v("对象")]),e._v("的类型")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const person1 = { name: '22', age: 1}\ntype Person = typeof person1\nPerson 类型为 { name: string; age: number }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("keyof T")]),e._v("  获得类型中的属性")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type Person = { name: string; age: number }\ntype Key = keyof Person \nkey 的类型为 'name' | 'age'\n")])]),e._v(" "),n("p",[e._v("通常我们可以通过 keyof 约束对象的传参， 如")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type Person = { name: string; age: number }\ntype Key = keyof Person;\ntype getPersonAtrribute = (person: Person, key: Key) => Person[Key];\n")])]),e._v(" "),n("p",[e._v("或者某些情况下我们想知道一个对象的属性值")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const workPerson = { \n\t'1': { name: '1', age: 1},\n\t'2': { name: '2', age: 2},\n}\ntype WorkPerson  = typeof workPerson;  // { '1': {name: string; age: number }, '2': {name: string; age: number }\ntype Key = keyof WorkPerson  // '1' | '2'\ntype Person = WorkPerson[Key]   // {name: string; age: number }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("|")]),e._v(" 类型兼容")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type width = 'string' | 'number';\n\n则 width 可以是 '32px' 也可以是 '32' 在 渲染时兼容两种类型\n")])]),e._v(" "),n("h3",{attrs:{id:"%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"}},[e._v("函数重载")]),e._v(" "),n("p",[e._v("定义不同类型的输入，推到出不同类型的输出")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type PersonListQuery = { user_ids: string[] };\ntype DongListQuery = { dog_ids: string[] };\nfunction getList(request: PersonListQuery): Person[];\nfunction getList(request: DogListQuery): Dog[];\n\nfunction getList(query: PersonListQuery | DogListQuery) {\n  if ('user_ids' in query) {  \n    return [] as Person[];\n  } else {\n    return [] as Dog[];\n  }\n}\n\nconst a = getList({ personIds: [], region: 'us'})\n此时 a 的类型将能推到出是 Person[]\n")])]),e._v(" "),n("h3",{attrs:{id:"%E6%B3%9B%E5%9E%8B"}},[e._v("泛型")]),e._v(" "),n("p",[e._v("类型的传参。 用 T 标识，在实际运用时你传入什么类型，该类型就作为后续推导。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("async function request<T>(url: string): Promise<T> {\n  const res = await fetch(url)\n  return res.json();\n}\n\nconst res = await request<Person>('getPersonInfo?id=1'); \n此时 ts 可以推导出 res 的类型是 Person\n")])]),e._v(" "),n("h3",{attrs:{id:"infer-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8"}},[e._v("Infer  类型参数使用")]),e._v(" "),n("p",[e._v("通过 Infer 一个类型为变量，定义出获取类型的方法")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("type addResultType<T> = T extends { a: infer U, b: infer U } ?  U : never;\ntype numberAdd =  addResultType<{ a: 1, b: 2 }>     // 推到出结果类型为 number\ntype textAdd = addResultType<{ a: 'hello', b: 'world' }>     // 推到出结果类型为 string\n")])]),e._v(" "),n("h3",{attrs:{id:"%E6%9E%9A%E4%B8%BE-enum"}},[e._v("枚举 enum")]),e._v(" "),n("p",[e._v("变量的值是约定的几个取值")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const enum PageType {\n  HOME = 'home',\n  VIDEO = 'video',\n}\n\nfunction getPageUrl(page: PageType) {\n  return {\n    [PageType.VIDEO]: \"/video\",\n    [PageType.HOME]: \"/home\",\n  }[page];\n}\n")])]),e._v(" "),n("h2",{attrs:{id:"tsconfig"}},[e._v("tsconfig")]),e._v(" "),n("p",[e._v("了解了 ts 对于类型的定义和各种规则后，我们则可以在编写 js 代码时利用并进行类型约束。于此同时，我们需要引入 typescript 库去获得这些 ts 能力。")]),e._v(" "),n("h3",{attrs:{id:"%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5"}},[e._v("如何引入")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("npm install  typescript  \n// 不必再多说\n")])]),e._v(" "),n("h3",{attrs:{id:"%E5%91%BD%E4%BB%A4"}},[e._v("命令")]),e._v(" "),n("p",[e._v("typescript 包是有命令文件的，通常 ts 的运行则是通过 tsc 配合相关命令去执行的. 具体命令大家可以安装包之后通过 tsc -h 查看"),n("br"),e._v(" "),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/349ffc362f0d831a780d2d7f754893a1.png",alt:"在这里插入图片描述"}})]),e._v(" "),n("h3",{attrs:{id:"%E9%85%8D%E7%BD%AE-%E5%AE%98%E7%BD%91"}},[e._v("配置 "),n("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html"}},[e._v("官网")])]),e._v(" "),n("p",[e._v("如果你看了 tsc 命令，你会发现它是有很多命令的，并且有的命令还伴随这相关参数。在工作文件夹中，我们则通过配置文件 "),n("code",{pre:!0},[e._v("tsconfig.js")]),e._v(" 去配置，保证在项目中的运用。 配置参数这里就不细讲了，还是看官方文档靠谱点。")])])},staticRenderFns:[]}},,function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h4",{attrs:{id:"%E4%B8%80-webpack-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"}},[e._v("一  webpack 是什么？")]),e._v(" "),n("p",[e._v("它是一个打包工具。 噗，完啦？")]),e._v(" "),n("p",[e._v("来，我们看官方概念:  webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。")]),e._v(" "),n("p",[e._v("内部如何构建一个依赖图，我们知道 webpack 会配置一个入口，这就是从这入口文件开始， 找到所有被依赖到的文件，比如其他 js / image / json 文件等，然后通过 loader 对这些文件进行处理、编译、打包、优化，生成一个 bundle 或者多个 bundle。")]),e._v(" "),n("h4",{attrs:{id:"%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86"}},[e._v("它的原理")]),e._v(" "),n("p",[e._v("通过以上，主要就是找依赖, 通过配置处理相应环境，根据你的需要配置插件进行优化（如 profill、babel、 miniSize etc) 打包出文件，可以放到服务器上运行。")]),e._v(" "),n("p",[e._v("关于找依赖，可以想到关于模块化的语法: import 、require、@import etc， 通过解析对应的语法寻找相应的依赖。然后通过读取依赖到的文件，根据对应的 loader 进行处理文件，最后根据你的插件配置，分割，压缩或注入等，根据 output config输出到对应的文件夹。")]),e._v(" "),n("p",[e._v("这里推荐一篇 "),n("a",{attrs:{href:"https://juejin.im/entry/5b0e3eba5188251534379615"}},[e._v("webpack原理")]),e._v(" 文章, 下面就提一提我最近遇到的一个很神奇的问题吧")]),e._v(" "),n("h4",{attrs:{id:"%E5%85%B3%E4%BA%8E-tree-shaking"}},[e._v("关于 "),n("a",{attrs:{href:"https://webpack.docschina.org/guides/tree-shaking/"}},[e._v("tree shaking")])]),e._v(" "),n("p",[e._v("想象抖一抖树，枯萎的叶子就会脱落。 这里指的是把没有用到的代码删除掉，从而减小文件的大小。通过这一优化，在引用多个第三方库时，能够大大的减少你的文件大小，但请确定这个包是没有副作用的。")]),e._v(" "),n("blockquote",[n("p",[e._v("什么是副作用?"),n("br"),e._v("\n就是在导入时会自行运行一段函数，从而改变了 window 变量啊或者其他的变量以供导入的包能正常运行， 而不是只单单 export 了变量。")])]),e._v(" "),n("p",[e._v("它是依赖于 es2015 的 "),n("code",{pre:!0},[e._v("静态导入导出( import / export)")]),e._v("。在打包时就会通过 import 确定引用包的 export 导出的某一个变量之一， 在告知没有副作用的情况下，删除掉没有用到的其他的导出代码。")]),e._v(" "),n("blockquote",[n("p",[e._v("静态导入是指一开始就默认加载这个文件，而不是一步一步执行代码判断逻辑，去导入对应文件")])]),e._v(" "),n("p",[e._v("webpack 在生成环境下，默认打开树抖动配置, 如下配置。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("optimization： {\n\tprovidedExports: true,\n\tusedExports: true,\n\tsideEffects: true,\n\tconcatenateModules: true,\n }\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("providedExports")]),e._v(" 开启 export 导出收集；"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("usedExportts")]),e._v(" 告诉webpack确定每个模块的已使用导出；"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("concatenateModules")]),e._v("  告诉webpack查找模块图的各个部分，这些部分可以安全地连接成一个模块；"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("sideEffects")]),e._v(" 告诉webpack识别 sideEffects 标志的 package.json 或规则以跳过模块，这些模块在未使用导出时被标记为不包含副作用， 则可以把无副作用的未使用的导出进行删除。")]),e._v(" "),n("p",[e._v("所以如果你的包无副作用，推荐在 package.json 设置 "),n("code",{pre:!0},[e._v("sideEffects: false")]),e._v(" 开启树抖动。"),n("br"),e._v("\n注意, 它会删掉样式文件，因为样式文件是没有 export 的。所以我们需要声明样式文件是有副作用的。"),n("br"),e._v("\n在 package.json 中设置：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("sideEffects: [\n\t'*.css'\n]\n")])]),e._v(" "),n("blockquote",[n("p",[e._v("总结，为了利用树木摇晃，你必须："),n("br"),e._v("\n1 使用ES2015模块语法 (配置 babel 禁止转义 es6 模块语义）"),n("br"),e._v('\n2 将"sideEffects"属性添加到项目的 package.json文件中。'),n("br"),e._v("\n3 配合压缩工具一起使用")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/cleverboy32/tree-shaking-css"}},[e._v("demo")]),n("br"),e._v("\n通过配置  "),n("code",{pre:!0},[e._v("webpack.prod.js")]),e._v(" sideEffects 值， 你可以看到 build 时 main.js 文件的大小发生改变。")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("###购买服务器")]),e._v(" "),n("p",[e._v("学生购买可以使用阿里云优惠专享， 每个月只要9.9 就好了。这里我用的是学生优惠，机型内存什么都限定好了的。所以- - 没什么可以说的。关于国内外服务器的区别就是，如果你购买了国外的服务器，就可以在云服务器上搭梯子访问国外的网站，也就是翻墙了。")]),e._v(" "),n("h3",{attrs:{id:"%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83"}},[e._v("安装环境")]),e._v(" "),n("p",[e._v("因为服务器默认 linux 系统，所以这里讲怎么配置 linux 云服务环境。"),n("br"),e._v("\n我第一次使用的时候，还以为是要去安装一个界面化桌面，以便我这个命令小白可以操作。但是，对于只有2G 的内存来说安装了之后将会很卡很卡。后来我问学长，他说不要安装界面化，使用命令就好了。")]),e._v(" "),n("p",[e._v("首先关于远程服务器的登录， 默认系统的用户名是 root, 然后登录密码可以在控制台进行修改。如下图点击重置密码。"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107170054918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"重置密码处"}})]),e._v(" "),n("p",[e._v("重置之后，然后点击远程连接，就可以连接登录到你的服务器上了。这里要将一点，如果你是 mac 电脑的话，可以在你的电脑上通过 ssh 登录到你的服务器。 命令如下："),n("br"),e._v(" "),n("code",{pre:!0},[e._v("ssh root@你的公网IP")]),e._v("，比如 "),n("code",{pre:!0},[e._v("ssh root@120.78.32.12")]),n("br"),e._v("\n然后输入密码即可连接成功。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20180107170503333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"登录成功图"}})]),e._v(" "),n("p",[e._v("接下来在终端中输入命令。配置环境。如果你是配置 java 环境，那么可以去谷歌一下如何在 linux 中配置 java 环境，这里我是配置的 node 环境，就讲一下如何配置 node 环境以及 npm。")]),e._v(" "),n("p",[e._v("这里我用的是源码安装。首先安装 node 编译依赖的第三方模块"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("yum -y install gcc make gcc-c++ openssl-devel")])]),e._v(" "),n("p",[e._v("然后下载 node 的源码包"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107171300036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("node 官网的源码 包。"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz")])]),e._v(" "),n("p",[e._v("你下载的时候可以手动改成当前最新版本。下载后，进行解压 "),n("code",{pre:!0},[e._v("tar -zxvf node-v8.9.4.tar.gz")]),e._v(", 然后进入解压后的文件夹 "),n("code",{pre:!0},[e._v("cd node-v8.9.4")]),e._v(", 依次"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("./configure")]),n("br"),e._v(" "),n("code",{pre:!0},[e._v("make")]),n("br"),e._v(" "),n("code",{pre:!0},[e._v("sudo make install")]),n("br"),e._v("\n这里编译时间会有点久，请耐心等待- -"),n("br"),e._v("\n查看安装成功"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107172311684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("安装 npm"),n("br"),e._v("\n同样下载 npm 包"),n("br"),e._v(" "),n("code",{pre:!0},[e._v("wget http://nodejs.org/dist/npm/npm-1.4.9.zip")]),n("br"),e._v("\n解压 "),n("code",{pre:!0},[e._v("tar -zxvf npm-1.4.9.tgz")]),n("br"),e._v("\n查看是否安装成功 "),n("code",{pre:!0},[e._v("npm -v")])]),e._v(" "),n("p",[e._v("这就是 node 环境配置了， 然后就是 mysql 数据库。"),n("br"),e._v(" "),n("a",{attrs:{href:"http://blog.csdn.net/win7system/article/details/53579500"}},[e._v("http://blog.csdn.net/win7system/article/details/53579500")])]),e._v(" "),n("p",[e._v("关于项目的上传，如果你本地编写了代码，想上传至服务器，第一个方式，可以是使用 ftp 上传文件。 第二个方式，就是在你的服务器上搭建一个 git 服务器，通过从服务器推送和克隆项目来获取文件。这里我使用的是第二种方法，参见教程："),n("br"),e._v(" "),n("a",{attrs:{href:"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000"}},[e._v("https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000")]),n("br"),e._v("\n这里注意一下， 关于 设置 ssh 登录，一定要把创建的 .ssh 文件放到你创建的用户下，如我这里是 git 用户，路径就是"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107174529969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("放置在正确位置之后，还要注意项目的归属者也要是 git 用户，这样才会在 git 用户里匹配到对应的 ssh key。也就是下面这一个步骤"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107174749168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("还有一点要注意的就是，你再本地推送了代码上 git 服务器之后，想要在云服务器上获取到代码， 需要在服务器上再次克隆 "),n("code",{pre:!0},[e._v("git clone git@server:/srv/sample.git")]),e._v(" 项目，git pull 获取到代码。 这里也可以通过自己配置 git 服务器的钩子函数，使其自动更新代码，我还没配置，就先不说了 - -。")]),e._v(" "),n("p",[e._v("好了，现在现在基本环境配置好了就可以开始开发你的项目啦。")]),e._v(" "),n("p",[e._v("另外附："),n("br"),e._v("\n项目在服务器上启动了，发现在本地电脑无法通过 ip 访问，那么可能是你的端口号没有开放，需要去服务器上设置安全组。"),n("br"),e._v("\n具体添加方法 ，以及其他一些关于服务器的配置，都可以随时点击右侧的 "),n("strong",[e._v("点我提问")]),e._v("，像云博士提问。 = ="),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20180107175548703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}})])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h3",{attrs:{id:"canvas"}},[e._v("canvas")]),e._v(" "),n("p",[e._v("canvas 是 HTML 5 新出的图片元素，它是 2d 绘图 API， 使用 JavaScript  调用API 可以画  lines, shapes, images, text 甚至其他你想话的， 并且不需要什么插件。")]),e._v(" "),n("p",[e._v("它是作为一个画布存在在网页中， 画布上有你绘制的图案，利用 js 你可以实时的改变画布上的图案，以实现动画。")]),e._v(" "),n("p",[e._v("它的支持性也挺好，IE 9 开始支持，Chrome和Opera 9+ 也支持。")]),e._v(" "),n("h3",{attrs:{id:"svg"}},[e._v("svg")]),e._v(" "),n("p",[e._v("SVG 可缩放矢量图形， 是 XML 用来描述二维图形和绘图程序的语言。目前SVG在Firefox、Opera、Webkit浏览器、IE等浏览器中已经部分实现。")]),e._v(" "),n("blockquote",[n("p",[e._v("什么是 XML"),n("br"),e._v("\n它是一种类似于 HTML 的标记语言，设计宗旨在于传输数据而不是显示数据。"),n("br"),e._v("\nXML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。通过读取你可以获取存储于其中的数据")])]),e._v(" "),n("p",[e._v("SVG可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将这两种方式结合起来创建图形。图形和其组成部分可以变形，可以合成，还可以通过滤镜完全改变外观。")]),e._v(" "),n("p",[e._v("SVG提供了一些元素，用于定义圆形、矩形、简单或复杂的曲线，以及其他形状。"),n("br"),e._v("\n一个简单的SVG文档由 "),n("code",{pre:!0},[e._v("<svg>")]),e._v(" 根元素和基本的形状元素构成。另外还有一个g元素，它用来把若干个基本形状编成一个组。")]),e._v(" "),n("p",[e._v("eg:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<svg version="1.1"\n     baseProfile="full"\n     width="300" height="200"\n     xmlns="http://www.w3.org/2000/svg">\n\n  <rect width="100%" height="100%" fill="red" />\n\n  <circle cx="150" cy="100" r="80" fill="green" />\n\n  <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>\n\n</svg>\n\n')])]),e._v(" "),n("p",[e._v("可以看到 svg 是在内部组合各种元素绘制形成相应的图案。 并且矢量顾名思义是可以自由缩放的，根据屏幕像素点进行缩放，保留了图案的高清晰度。")]),e._v(" "),n("h3",{attrs:{id:"%E6%80%BB%E7%BB%93"}},[e._v("总结")]),e._v(" "),n("p",[e._v("通过以上，我们可以知道 svg 和 canvas 的相同点，它们都是可以绘图的元素，并有自身的用法。"),n("br"),e._v("\ncanvas 是一块画布，纯用 js 去画画的。根据你的 js 编写，动态去渲染画布上的图案，适用一些大量数据交互修改的，比较复杂的动画。由于它仅仅是根据你设定的大小，它是依赖于分辨率的。"),n("br"),e._v("\n而 svg 是一个个元素组成在一起的， 包含 animate 元素，可做一些小小的动画， 它的矢量优点也更适合做一些高保真的静态图片。")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h1",{attrs:{id:"%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86"}},[e._v("安全意识")]),e._v(" "),n("p",[e._v("你要离开家了, 所有的父母都会说，路上注意安全，可见安全是多么的重要！那么作为软件开发，有哪些危险使我们要知道并避免的呢？"),n("br"),e._v("\n下面我说一些基本的需要知道的安全攻击, 以及应对方案。")]),e._v(" "),n("blockquote",[n("p",[e._v("ps 作为一个安全小白，了解各种各样的防范方案真的太难了，我是真的水🤭。欢迎补充，以增长见识")])]),e._v(" "),n("h2",{attrs:{id:"xss%3A-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"}},[e._v("XSS: 跨站脚本攻击")]),e._v(" "),n("p",[e._v("在用户可以输入的地方，并且将作为代码编译时，攻击者可以通过输入一个脚本地址的方式进行对页面注入脚本攻击。解决方式: 任何用户输入的地方都不要相信，对用户输入内容进行转义，如 "),n("code",{pre:!0},[e._v("<")]),e._v(" 使用转义字符串 "),n("code",{pre:!0},[e._v("&lt;")]),e._v(" 代替。")]),e._v(" "),n("h2",{attrs:{id:"csrf%3A-%E8%B7%A8%E7%AB%99%E4%BC%AA%E8%A3%85%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB"}},[e._v("CSRF: 跨站伪装请求攻击")]),e._v(" "),n("p",[e._v("在用户已登录的情况下，伪装用户的身份发起请求，进行相关攻击。解决方式，确认用户的身份。比较好理解的解决方式是: 二次确认，通过用户的二次确认确认请求方为真实用户。然后就是 X-Requested-With  请求标志，通过该请求头设置标志位 "),n("code",{pre:!0},[e._v("ajax")]),e._v(" 请求，可以一定程度阻止跨域的伪装。"),n("code",{pre:!0},[e._v("Anti-CSRF TOKEN")]),e._v(" 方案：通过服务端与客户端唯一的 token 值进行校验，可以看做一个暗号，让别人无法伪装！")]),e._v(" "),n("h2",{attrs:{id:"%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81"}},[e._v("网络劫持")]),e._v(" "),n("h3",{attrs:{id:"jsonp-%E5%8A%AB%E6%8C%81"}},[e._v("Jsonp 劫持")]),e._v(" "),n("p",[e._v("我们都知道 "),n("code",{pre:!0},[e._v("jsonp")]),e._v(" 就是为了解决跨域的，如果传输信息设计到比较敏感的数据，那么别人可以很方便调用你的接口，获取你的数据，存储在自己的数据库中。解决方法，添加脚本可运行白名单，不要传输敏感信息。")]),e._v(" "),n("h3",{attrs:{id:"http-%E5%8A%AB%E6%8C%81%E3%80%82"}},[e._v("HTTP 劫持。")]),e._v(" "),n("p",[e._v("HTTP 是明文传输，所以运营商可以知道你的代码是什么，然后在里面加一点小广告什么的，改变你的内容。解决方法就是使用 https 协议，可耻的运营商")]),e._v(" "),n("h3",{attrs:{id:"dns-%E5%8A%AB%E6%8C%81"}},[e._v("DNS 劫持")]),e._v(" "),n("p",[e._v("通过域名解析我们才能找到对域名的服务器 ip 地址，劫持了 DNS 就可以给你返回一个错误的 ip 地址。在 dns 解析中，会先在本机搜索域名解析记录，无相关记录像 dns 服务商发起请求。所以要么你本地信息被篡改，要么服务商欺骗你。"),n("br"),e._v(" "),n("a",{attrs:{href:"https://juejin.im/post/5cff858a6fb9a07ed84238ec"}},[e._v("转一篇 DNS 劫持详解链接")])]),e._v(" "),n("h2",{attrs:{id:"%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8"}},[e._v("接口安全")]),e._v(" "),n("h3",{attrs:{id:"%E6%95%B0%E6%8D%AE%E5%BA%93"}},[e._v("数据库")]),e._v(" "),n("p",[e._v("数据库，插入数据库的参数，在执行 sql 的时候小心它把你整个数据库表给删了。这里的攻击类似 "),n("code",{pre:!0},[e._v("xss")]),e._v(" 攻击，通过传输、拼接一些字符串改变原本的 sql 语义")]),e._v(" "),n("h3",{attrs:{id:"%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF"}},[e._v("推送消息")]),e._v(" "),n("p",[e._v("比如短信发送消息，非常的有代表性。通过接口的参数传递，以及最后的发送内容，可以推测出你的推送内容的组合相关方式，就可以通过不良参数，很方便的发送的一些不合法的信息，或有毒链接给用户。解决方式就是不要相信用户传入的任何参数，对参数进行校验，发送内容尽量可选择匹配模式，如 code 值映射，对不合法的参数才有默认内容发送。")]),e._v(" "),n("h2",{attrs:{id:"ddos%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1"}},[e._v("DDOS：分布式拒绝服务")]),e._v(" "),n("p",[e._v("就是很多请求大量涌入你的服务器，导致它们都没有空闲可以响应真正的用户请求。通过 TCP 连接，我们知道建立连接需要三次确认，一般攻击者可以伪造 ip, 发起大量连接请求，却又不确认 = = 导致服务器白白等待直到超时。其次可以借用别的用户，在一个大流量用户网站地方的某一个页面上了，通过 "),n("code",{pre:!0},[e._v("xss")]),e._v(" 默认发起对攻击网站的请求，并发送很大的数据，但每次发送很少的字节，这些用户就被当成了肉鸡，然后使其瘫痪。解决防范：增加机器， 对同一个ip 的过多请求进行防范。")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("作为一个前端，写页面结构，写CSS怎么命名?"),n("br"),e._v("\n就算不用，但你的了解， 让自己的代码更规范。")]),e._v(" "),n("h5",{attrs:{id:"bem%E6%98%AF%E4%BB%80%E4%B9%88"}},[e._v("BEM是什么")]),e._v(" "),n("p",[e._v("它是css命名的一种规范。试想，你写了一个页面，有input, button, div, 这些元素是什么样的关系，给他们添加样式的时候，怎么知道他们是一个页面的？ 怎么知道input 是否放在div里面的？ 不要急，这就说到了下面的命名之作用")]),e._v(" "),n("h4",{attrs:{id:"bem%E6%98%AF%E6%80%8E%E4%B9%88%E5%91%BD%E5%90%8D%E7%9A%84"}},[e._v("BEM是怎么命名的")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":"",class:"language-html"}},[n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("html")]),e._v(">")]),e._v("\n\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("div")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from"')]),e._v(">")]),e._v("\n\t\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("input")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from__input"')]),e._v("/>")]),e._v("\n\t\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("button")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from__confim"')]),e._v(">")]),e._v("确定"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("button")]),e._v(">")]),e._v("\t\n\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("div")]),e._v(">")]),e._v("\n"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("html")]),e._v(">")]),e._v("\n")])]),e._v(" "),n("p",[e._v("通过上面命名可以很直接看出，input 和button 在div 里面。"),n("br"),e._v("\n这里讲 后面的 __input/__confim 这里后面接两个下划线，表示的是div里面的子元素。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":"",class:"language-html"}},[n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("html")]),e._v(">")]),e._v("\n\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("div")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from--big"')]),e._v(">")]),e._v("\n\t\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("input")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from__input"')]),e._v("/>")]),e._v("\n\t\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("<"),n("span",{attrs:{class:"hljs-name"}},[e._v("button")]),e._v(" "),n("span",{attrs:{class:"hljs-attr"}},[e._v("class")]),e._v("="),n("span",{attrs:{class:"hljs-string"}},[e._v('"loggin-from__confim"')]),e._v(">")]),e._v("确定"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("button")]),e._v(">")]),e._v("\t\n\t"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("div")]),e._v(">")]),e._v("\n"),n("span",{attrs:{class:"hljs-tag"}},[e._v("</"),n("span",{attrs:{class:"hljs-name"}},[e._v("html")]),e._v(">")]),e._v("\n")])]),e._v(" "),n("p",[e._v("这里说， --big表示添加的描述， 很明显是大的注册表单的样式嘛。")]),e._v(" "),n("h4",{attrs:{id:"bem%E6%80%BB%E7%BB%93"}},[e._v("BEM总结")]),e._v(" "),n("p",[e._v("好了， 这里loggin-from 相当于一块整体(block)， 里面包含了元素input/button(element), 还有这个块或者一些元素的修饰big(modifier) => BEM"),n("br"),e._v("\n它一般和sass一起使用，在用@C代表块、 @d代表元素、 @m代码修饰符的时候， css可以这样写了")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@C loggin-from {\n\twidth: 100px;\n\theight: 100px;\n\t@m big {\n\t\twidth: 200px;\n\t\theight: 200px;\n\t}\n\t@d input {\n\t\tcolor: red;\n\t}\n\t@d button {\n\t\tcolor: blue;\n\t}\n}\n")])]),e._v(" "),n("p",[e._v("怎么样，这样是不是就不用写那么长了， 而且一看样式文件，就能知道页面布局是什么样的。"),n("br"),e._v(" "),n("strong",[e._v("以上写法， 要通过sass 插件配置的")]),n("br"),e._v("\n这里有一个包 ，可以使用"),n("a",{attrs:{href:"https://www.npmjs.com/package/sass-bem-constructor"}},[e._v("sass-bem-constructor")])])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h1",{attrs:{id:"cleverboy-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"}},[e._v("cleverboy 的学习笔记")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("当我们要完成一个应用的时候，会根据对应的功能划分为许多不同的模块，就像一个论坛，有发帖的模块，评论的模块，js 中的模块也正是如此，一个具体功能的代码抽成一个文件，当你做一个东西的时候需要用到这个功能的时，可以直接使用这个文件，实现功能的分离，并能在多个需要的地方使用。就像是螺丝钉、螺丝帽、垫片一样的，通过组合使用实现出你的产品。")]),e._v(" "),n("p",[e._v("通过直白的描述，我们可以知道，模块化的好处就是，抽离代码，重复使用，如现在很直观的代表 npm 包。")]),e._v(" "),n("p",[e._v("那么模块化到底是怎么实现的呢？")]),e._v(" "),n("p",[e._v("先来了解一下历史，以前的 html 不知道大家还记不记的， 一个html 页面引入了多个 js 文件.")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <title>So UI - A Component Library for Vue.js.</title>\n</head>\n<body>\n    <div id="app"></div>\n    <script src="a.js"><\/script>\n    <script src="b.js"><\/script>\n    <script src="c.js"><\/script>\n    <script src="d.js"><\/script>\n    <script src="e.js"><\/script>\n</body>\n</html>\n')])]),e._v(" "),n("p",[e._v("如上，引入了 a/b/c/d/e 五个文件，这五个文件如果相互之间有依赖，还要注意引入的顺序，并且还需要注意它们里面的变量名，若是重复利用到其他的项目，其他项目也需要注意到以上两点问题。为了解决这一问题，就有了模块化的规范。")]),e._v(" "),n("p",[e._v("模块化的规范，有 "),n("a",{attrs:{href:"http://javascript.ruanyifeng.com/nodejs/module.html"}},[e._v("CMD")]),e._v("  和 "),n("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html"}},[e._v("AMD")])]),e._v(" "),n("p",[e._v("CMD (Common Module Definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。它主要特点是：对于依赖的模块是延迟执行，依赖可以就近书写，等到需要用这个依赖的时候再引入这个依赖，应用有sea.js.")]),e._v(" "),n("p",[e._v("AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js")]),e._v(" "),n("p",[e._v("尽情的猜测，require.js 是怎么弄的呢？ 它需要依次的加载模块然后去进行相应的操作，加载模块就是要引入这个文件，那么这里也还是通过动态加载 script 的方法，并通过 onload 去执行后面的回调了。")]),e._v(" "),n("p",[e._v("我们知道现如今 es6 已经支持模块化了，它分为 export 和 import 两个命令。 export 导出你定义的模块变量， import 引入一个模块变量。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("export { \n \tone, \n \ttwo\n }\n export default three;\n")])]),e._v(" "),n("p",[e._v("对应的引入代码")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("import  { one, two }  three from 'a.js'\n")])]),e._v(" "),n("p",[e._v("可以看到 export 可以导出一个默认的变量，也可以导出变量对象，这里引入的时候名字不要写错了。 那么 es6 的模块化通过babel 转码其实就是 umd 模块规范， 它是一个兼容 cmd 和 amd 的模块化规范, 同时还支持老式的“全局”变量规范")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS之类的\n        module.exports = factory(require('jquery'));\n    } else {\n        // 浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    方法\n    function myFunc(){};\n \n    //    暴露公共方法\n    return myFunc;\n}));\n")])]),e._v(" "),n("p",[e._v("那么浏览器是如何支持这种规范的呢？"),n("br"),e._v("\n其实是实现了根据这种规范定制出来的功能。这里我们就按照 实现了 AMD 规范的 require.js 来讲一下实现代码。")]),e._v(" "),n("p",[e._v("AMD 定义一个模块的方法是 define(id?, dependencies?, factory)。")]),e._v(" "),n("p",[e._v("参考define 的方法代码")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(" define = function (name, deps, callback) {\n        var node, context;\n        \n        //Allow for anonymous modules\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps && isFunction(callback)) {\n            deps = [];\n            //移除注释\n            //查找 require 语句，收集依赖到 deps 里面\n            // but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, commentReplace)\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute('data-requiremodule');\n                }\n                context = contexts[node.getAttribute('data-requirecontext')];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        if (context) {\n            context.defQueue.push([name, deps, callback]);\n            context.defQueueMap[name] = true;\n        } else {\n            globalDefQueue.push([name, deps, callback]);\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n    \n\treq.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n")])]),e._v(" "),n("p",[e._v("可以知道，这一段代码是解析定义是模块所需的依赖放置 context 的模块定义队列中。然后我们就要通过 req 去执行加载依赖，我们来看看 req 的定义。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("req = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n       \n        if (config) {\n            context.configure(config); // 完善配置\n        }\n\n        return context.require(deps, callback, errback); \n")])]),e._v(" "),n("p",[e._v("这里的代码把 依赖，回调， 错误处理和配置项都传进来了，进行了配置上的处理之后，我们可以看到最后再去根据配置加载。"),n("br"),e._v("\n我们再来看 context.require 方法")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("makeRequire: function (relMap, options) {\n\t\toptions = options || {};\n\t\tfunction localRequire(deps, callback, errback) {\n\t\t\t.... 当前 require 的转换\n      \t \treturn localRequire;\n  \t\t }\n\t\tcompleteLoad: function (moduleName) {\n\t\t\t判断 context 的依赖队列，是继续加载还是执行回调\n\t\t}\n\t\t nameToUrl: function (moduleName, ext, skipExt) {\n\t\t \t根据模块名和配置得到加载的路径\n\t\t }\n\t\t load: function (id, url) {\n\t               req.load(context, id, url);\n\t      },\n\t      execCb: function (name, callback, args, exports) {\n\t                return callback.apply(exports, args);\n\t        },\n\t\tonScriptLoad: function (evt) {\n\t\t\t脚本加载完成后得到数据，执行 context.completeLoad(data.id);\n\t\t}\n\t\tonScriptError: function (evt) {\n\t\t\t加载错误执行错误处理\n\t\t}\n\t};\n   context.require = context.makeRequire();\n")])]),e._v(" "),n("p",[e._v("那我们知道其实就是围着这语法的解析，进行一系列的脚本加载，然后执行回调。")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("vue 是一个 js 框架，它实现了自己的模板，通过 .vue 文件可以经过编译成一个数据改变驱动视图改变的 js代码。"),n("br"),e._v("\n那么这其中又是经历了什么样的步骤呢？")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("一个 vue 对象是通过 new Vue({options}) 来得到的，也就是构造函数了。我们来看这个函数")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("function Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n// 这里是一系列对这个函数进行的继承\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n")])]),e._v(" "),n("p",[e._v("可以看到这个 Vue 构造函数，它经历了 5 个系列的mixin，并在新创建时会运行 _init(options) 方法。"),n("br"),e._v("\n那么我们来看看, 这五个 mixin 分别做了啥。")]),e._v(" "),n("h5",{attrs:{id:"%E7%AC%AC%E4%B8%80%E4%B8%AA-initmixin"}},[e._v("第一个  initMixin")]),e._v(" "),n("p",[e._v("它只做了一件事， 定义了 _init 方法，那么你就知道创造一个Vue 实例，它执行的 _init 方法就是上面这个方法了。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Vue.prototype._init = function (options?: Object) {\n....\n}\n")])]),e._v(" "),n("h5",{attrs:{id:"%E7%AC%AC%E4%BA%8C%E4%B8%AA-statemixin"}},[e._v("第二个 stateMixin")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("  Object.defineProperty(Vue.prototype, '$data', dataDef)  // 能够返回 data\n  Object.defineProperty(Vue.prototype, '$props', propsDef) // 能够返回 props\n  Vue.prototype.$set = set // 就是我们用的 this.$set(this.people, 'name', ‘clever')方法, 下同。\n  Vue.prototype.$delete = del\n  Vue.prototype.$watch = function (\n   ....\n  }\n")])]),e._v(" "),n("h5",{attrs:{id:"%E7%AC%AC%E4%B8%89%E4%B8%AA-eventsmixin"}},[e._v("第三个 eventsMixin")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Vue.prototype.$on = function (eventname, fn) {\n....\n}\nVue.prototype._$once = function (eventname, fn) {\n // 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。\n}\nVue.prototype._off = function (event, fn) {\n// 移除自定义事件监听器。\n}\nVue.prototype.$emit = function (event) {\n// 触发一个事件\n}\n")])]),e._v(" "),n("h5",{attrs:{id:"%E7%AC%AC%E5%9B%9B%E4%B8%AA-lifecyclemixin"}},[e._v("第四个 lifecycleMixin"),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/0227c8c15285fbd179573e7cd8cb4718.png",alt:"在这里插入图片描述"}})]),e._v(" "),n("h5",{attrs:{id:"%E7%AC%AC%E4%BA%94%E4%B8%AA-rendermixin"}},[e._v("第五个 renderMixin"),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/715399a9ac35cef7c3aca2d3242ca5a3.png",alt:"在这里插入图片描述"}})]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("好， 这个 Vue 继承了这些方法，它已经是一个完整的 Vue 了，而新创建的时候要执行 _init 方法了, 现在我们来看看这个方法里面做了写啥")]),e._v(" "),n("ul",[n("li",[e._v("vm._uid = uid++ 创建 uid")]),e._v(" "),n("li",[e._v("合并 options")]),e._v(" "),n("li",[e._v("initLifecycle"),n("br"),e._v("\ninitEvents(vm)"),n("br"),e._v("\ninitRender(vm)"),n("br"),e._v("\ncallHook(vm, 'beforeCreate')"),n("br"),e._v("\ninitInjections(vm) // resolve injections before data/props"),n("br"),e._v("\ninitState(vm)"),n("br"),e._v("\ninitProvide(vm) // resolve provide after data/props"),n("br"),e._v("\ncallHook(vm, 'created')")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("关于 initLifecycle\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n  vm.$children = []\n  vm.$refs = {}\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n")])]),e._v(" "),n("ul",[n("li",[e._v("initEvents")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("  vm._events = Object.create(null)\n  vm._hasHookEvent = false\n  // init parent attached events\n  const listeners = vm.$options._parentListeners\n  if (listeners) {\n    updateComponentListeners(vm, listeners)\n  }\n  就是判断父级是否有事件监听，然后给父级进行监听事件\n")])]),e._v(" "),n("ul",[n("li",[e._v("initRender")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("   vm._vnode = null  // the root of the child tree\n  vm._staticTrees = null  // v-once cached trees\n  const options = vm.$options\n  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree\n  const renderContext = parentVnode && parentVnode.context\n  vm.$slots = resolveSlots(options._renderChildren, renderContext)\n  vm.$scopedSlots = emptyObject\n  // 实例绑定 createElement 方法，以便可以正常在内部渲染\n // 参数顺序   tag, data, children, normalizationType, alwaysNormalize\n  // 内部使用从模板编译而来的渲染函数\n  \n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  // 公共版本必须是 normalization 的渲染函数\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n\n  // $attrs & $listeners 应该被监听热更新\n  const parentData = parentVnode && parentVnode.data\n\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {\n      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)\n    }, true)\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {\n      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)\n    }, true)\n  } else {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)\n  }\n")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("callHook(vm, 'beforeCreate') 执行 beforeCreate 函数")])]),e._v(" "),n("li",[n("p",[e._v("initInjections(vm) 收集注入的依赖")])])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("  const result = resolveInject(vm.$options.inject, vm)\n  if (result) {\n    toggleObserving(false)\n    Object.keys(result).forEach(key => {\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], () => {\n          warn(\n          \t`避免直接改变注入的值，因为将会重新渲染所提供这个值的组件, \n          \t改变的值是: \"${key}\",\n            vm\n          )\n        })\n      } else {\n        defineReactive(vm, key, result[key])\n      }\n    })\n    toggleObserving(true)\n")])]),e._v(" "),n("ul",[n("li",[e._v("initState 监听值收集依赖")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props) // 赋值 props 数据并收集依赖\n  if (opts.methods) initMethods(vm, opts.methods) // 赋值 vue 的各个 method\n  if (opts.data) {\n    initData(vm) // 收集依赖\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed) // 收集依赖\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch) // 初始化你写的监听对象\n  }\n \n")])]),e._v(" "),n("ul",[n("li",[e._v("initProvide")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("  const provide = vm.$options.provide\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide\n  }\n")])]),e._v(" "),n("ul",[n("li",[e._v("callHook(vm, 'created') 执行 created 函数")])]),e._v(" "),n("blockquote",[n("p",[e._v("这就是 _init 中各个函数所做的了。 我们可以看到总结过来就是"),n("br"),e._v("\n1.初始化了生命状态"),n("br"),e._v("\n2.进行事件上的监听"),n("br"),e._v("\n3.渲染视图的初始化；收集所用到的父组件的数据或事件"),n("br"),e._v("\n4.调用你写的 beforeCreate 方法"),n("br"),e._v("\n5.initState, 处理了 vue 中的各种数据(props/data/methods.....), 也在这一步针对这些数据进行了依赖收集，数据更新绑定"),n("br"),e._v("\n6.初始化了 provide 的值， 也可以看出它没有被收集依赖， 是不会影响视图改变的"),n("br"),e._v("\n7.调用了你写的 created 方法了。")])]),e._v(" "),n("p",[e._v("以上，就是你 let app = new Vue() 这一步所发生的所有事情了。")]),e._v(" "),n("p",[e._v("那通过平时的使用我们知道，我们是通过调用 $mounted 能把它挂载上页面。所以接下来我们就可以来看看 vue 自己的 $mount 都做了些什么?")]),e._v(" "),n("p",[e._v("答: 就是把 template 或直接写的 render 函数，进行指令、事件等vue 中的语法解析编译成一个 AST 树。通过这个树，通过之前 initRender 中的 $createElement 方法可以生成虚拟DOM, 然后添加到页面中出，不就渲染出来了么。 如果大家使用过 Vue 的 $createElement 方法，相信就知道这个 ast 是怎么一个结构了，拿示例的来说")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("createElement(\n  'div',\n  [\n    '先写一些文字',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n")])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("说完了整个过程，现在还比较疑惑的就是它的收集依赖，然后数据改变引起的视图改变到底怎么做呢？")]),e._v(" "),n("p",[e._v("也就是说我们要实现一个模式，vm 可能 data 对象中的一个值，比如 name 改变了，然后就调用重新渲染的函数，这里为了性能，是生成了一个虚拟 Dom, 然后比较哪里改变了进行相应的替换。"),n("br"),e._v("\n把这个模式抽象出来，就是我们需要一个")]),e._v(" "),n("p",[e._v("先说具体实现： 我们视图更新依赖到的值收集起来，这里把每一个依赖到的值称作 dep。每个依赖订阅与它有关的 vue 的 watcher 中心， 这里把 dep 所订阅的 watcher 叫做 sub。 那么 dep 被改变的时候，获取它订阅了那些 watcher， 通知他们进行 update 视图啦。")]),e._v(" "),n("p",[e._v("可以看我画的简图"),n("br"),e._v(" "),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/417c23088cb0224c6a4464651452c604.png",alt:"在这里插入图片描述"}}),n("br"),e._v(" "),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/59c0e76f684052df524761ee8f4f6942.png",alt:"在这里插入图片描述"}})]),e._v(" "),n("p",[e._v("这就是依赖对象 和 一个 watcher 对象所涉及到的处理了。"),n("br"),e._v("\nVue 中又是怎么把一个个的属性，进行操作变成依赖的呢？"),n("br"),e._v("\n对应它的源码就是 defineReactive 方法。源码如图：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("export function defineReactive (obj, key, val, customSetter, shallow) {\n  const dep = new Dep()\n  \n  // 迎合预定义的getter / setter\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n  \n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n")])]),e._v(" "),n("p",[e._v("这里就是用的 Object.defineProperty 方法，它可以重写对象的属性的 get 和 set 方法。 当这个属性在 Vue 中被获取的时候，就开始收集依赖，把它收集在这个 vm 的 watcher 中心，并且让它订阅这个 watcher 。当这个属性被重新设置时， 就通知它所订阅的对象去更新。")]),e._v(" "),n("p",[e._v("大致要知道的就是这些了。关于具体是怎么实现把 template  编译成 ast 树， 具体是怎么把事件绑定上去的，你可以尽情的去猜想和推测，或者去看看具体的实现方式。但是 VUE 框架总体来说所做的就是这些事情了, 如果有觉得本文写的不清楚的地方可以提哈 = =")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("h3",{attrs:{id:"%E4%BB%80%E4%B9%88%E6%98%AF-ssl-%E8%AF%81%E4%B9%A6"}},[e._v("什么是 SSL 证书")]),e._v(" "),n("p",[e._v("SSL 证书是数字证书，是由证书认证机构（CA）对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机构的公章）后形成的一个数字文件。"),n("br"),e._v("\n通俗一点， 就是包含了所使用的服务器的信息和公钥，这些信息是公开的。 而私钥是由证书申请者自己保存的，是保密的。")]),e._v(" "),n("h3",{attrs:{id:"%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%91%A2"}},[e._v("怎么配置呢")]),e._v(" "),n("p",[e._v("要在服务器要发送SSL证书，那么在服务器上配置。首先你得有一个"),n("code",{pre:!0},[e._v("证书")]),e._v("！"),n("br"),e._v("\n证书如何获取，我也是百度了很多，也有很多免费的网站，ssl for free, freessl.org, 但是发现证书没有.crt 文件，或者验证域名不方便。")]),e._v(" "),n("p",[e._v("######这里先讲一下 SSL 证书包含的几个文件："),n("br"),e._v(" "),n("code",{pre:!0},[e._v(".key")]),e._v("  =>     私钥"),n("br"),e._v(" "),n("code",{pre:!0},[e._v(".csr")]),e._v("   =>    公钥，让你的证书去认证的时，可以把它发送给权威机构认证。"),n("br"),e._v(" "),n("code",{pre:!0},[e._v(".crt")]),e._v("  =>    证书了")]),e._v(" "),n("p",[e._v("这里可以自己去体验一下用 OpenSSL 给自己生成一个证书。需自行安装 openssl 软件"),n("br"),e._v(" "),n("a",{attrs:{href:"https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html"}},[e._v("openssl 给自己颁发证书的步骤")])]),e._v(" "),n("p",[e._v("openssl 的证书既然是自己给自己颁发的，那么就不具有权威性，在连接时会向客户端提示不是安全的链接。也没有小绿锁。")]),e._v(" "),n("p",[e._v("最后我发现腾讯云有免费的证书可以用。"),n("br"),e._v(" "),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/6c5cab65c69586f9228ecf2896a12ad0.jpeg",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("申请好证书之后， 如图"),n("br"),e._v(" "),n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/6aa539ccc93a564348a6b975a998cf80.jpeg",alt:"这里写图片描述"}}),n("br"),e._v("\n点击详情可以看到 "),n("a",{attrs:{href:"https://cloud.tencent.com/document/product/400/4143"}},[e._v("指引文档")]),e._v(", 里面的服务器配置方法就很全面了, 不管你是不是用它的证书，都可以按照这样去配。")]),e._v(" "),n("h3",{attrs:{id:"%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B-ssl-%E5%B7%A5%E4%BD%9C"}},[e._v("了解一下 SSL 工作")]),e._v(" "),n("p",[e._v("我们知道，在客户端和服务器之间的请求，就是来回发送数据，普通的 HTTP 协议是没有对数据进行加密的，那么可能被第三方截取到你的请求，改变你们的通信数据或者冒充身份发送信息给你。 哇，突然感觉这些很常见 = =")]),e._v(" "),n("p",[e._v("HTTPS  就是一种安全的通信了，它会加密你的数据， 使第三方无法获取，并在建立通信的握手阶段，互相确认身份， 使别人无法冒充身份。 SSL 证书就是使用在 握手阶段，通过证书的信息，确认服务器身份。"),n("br"),e._v("\n具体如下：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/29104c17fe7cebb091ec79ad1714bc32.png",alt:"这里写图片描述"}})]),e._v(" "),n("p",[e._v("详细讲解每一步就是："),n("br"),e._v("\n第一步：客户端 say hello, 向服务端发送自己生成的 random 数，和自己支持的加密方法。")]),e._v(" "),n("p",[e._v("第二步：服务端接收消息后，又向客户端发送自己生成的 random 数、SSL 证书，确定使用的加密方法。")]),e._v(" "),n("p",[e._v("第三步：客户端读取证书信息，确认证书有效，然后自己再生成一个 random 数，并使用证书的公钥进行加密，发送给服务端。")]),e._v(" "),n("p",[e._v("第四步：服务端使用自己本地的私钥，解密获取客户端的随机数。")]),e._v(" "),n("p",[e._v("第五步：客户端和服务端使用这三个随机数生成 "),n("code",{pre:!0},[e._v("对话密钥")]),e._v(", 用来加密接下来的对话过程。")]),e._v(" "),n("p",[e._v("可以看到下面英文有提到 session。 因为如果每次建立连接都去进行这五步，那么会很浪费时间。  所以这里有 sessionID 和 session ticket 两种。")]),e._v(" "),n("p",[e._v("session ID，记录有本次的握手存在，再次发送信息时，客户端发送该ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。")]),e._v(" "),n("p",[e._v("session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。")])])},staticRenderFns:[]}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("undefined",[n("p",[e._v("###"),n("strong",[e._v("什么是PWA")]),n("br"),e._v("\n先说一下全名，progressive web app： 渐进式网页应用。这是谷歌推出的，我是这样理解的：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("我们一般写web应用，在 pc 上是没有缓存的，打开页面的时去请求数据。")])]),e._v(" "),n("li",[n("p",[e._v("第二个也没有像 app 一样的小图标放在桌面，一点开就进入了应用，而是通过打开浏览器输入网址，")])]),e._v(" "),n("li",[n("p",[e._v("第三个就是，不能像 app 一样给用户推送消息，像微博会跟你推送说有谁评论了你的微博之类的功能。")])])]),e._v(" "),n("p",[e._v("而谷歌推出的 pwa，就是具有这些了这些特点， 使我们的 web 应用，能够像一款 app 一样使用。并且对比与 app, 它不用复杂的安装，也不用下载更新包，刷新页面就可以了(注意到缓存的处理)。")]),e._v(" "),n("p",[e._v("####"),n("strong",[e._v("那么这些功能分别是怎么实现的呢？")]),n("br"),e._v(" "),n("strong",[e._v("关于缓存")])]),e._v(" "),n("p",[e._v("其实这个就是 我们平时做的 Session 啊、localStorage、CacheStorage 之类的。")]),e._v(" "),n("p",[e._v("这里用的就是 "),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage"}},[e._v("cacheStorage")]),e._v(" 缓存，它提供了一个ServiceWorker类型的工作者或window范围可以访问的所有命名缓存的主目录, 并维护字符串的映射名称到相应的 Cache 对象。"),n("br"),e._v("\n主要方法包括："),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdn.net/20171112212302073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}}),n("br"),e._v("\n有了这些方法你可以对你的缓存进行操作。目前还在草案状态，仅火狐和谷歌浏览器支持此特性。")]),e._v(" "),n("p",[e._v("PWA是通过 ServiceWorker 访问 cache ,所以需要注册 ServiceWorker 工作者。在之前别忘记判断浏览器是否支持。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("if ('serviceWorker' in navigator) {\n\tnavigator.serviceWorker.register(sw.js) // 注册sw.js 文件中变成的服务对象，返回注册成功的对象\n\t.then(function(swReg){\n          swRegistration = swReg;\n     }).catch(function(error) {\n          console.error('Service Worker Error', error);\n     });\n}\n")])]),e._v(" "),n("p",[e._v("这个 "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"}},[e._v("Service Worker")]),e._v(" 服务工作者就厉害了，它相当于浏览器和网络之间的代理服务器，可以拦截网络请求，做一些你可能需要的处理(请求资源从缓存中获取等)。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("它能够创建有效的离线体验，拦截网络请求，并根据网络是否可用判断是否使用缓存数据或者更新缓存数据。")])]),e._v(" "),n("li",[n("p",[e._v("它们还允许访问推送的通知和后台的API。")])])]),e._v(" "),n("p",[e._v("关于 sw.js 中具体的缓存的代码：")]),e._v(" "),n("p",[e._v("创建需要缓存的文件")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("'use strict'\nlet cacheName = 'pwa-demo-assets'; // 缓存名字\nlet imgCacheName = 'pwa-img';\nlet filesToCache;\nfilesToCache = [ // 所需缓存的文件\n    '/',\n    '/index.html',\n    '/scripts/app.js',\n    '/assets/imgs/48.png',\n    '/assets/imgs/96.png',\n    '/assets/imgs/192.png',\n    '/dist/js/app.js',\n    '/manifest.json'\n];\n\nself.addEventListener('install', function(e) {\n    e.waitUntil(\n\t    // 安装服务者时，对需要缓存的文件进行缓存\n        caches.open(cacheName).then(function(cache) {\n            return cache.addAll(filesToCache);\n        })\n    );\n});\n\n\nself.addEventListener('fetch', (e) => {\n    // 判断地址是不是需要实时去请求，是就继续发送请求\n    if (e.request.url.indexOf('/api/400/200') > -1) {\n        e.respondWith(\n            caches.open(imgCacheName).then(function(cache){\n                 return fetch(e.request).then(function (response){\n                    cache.put(e.request.url, response.clone()); // 每请求一次缓存更新一次新加载的图片\n                    return response;\n                });\n            })\n        );\n    } else {\n        e.respondWith(\n\t        // 匹配到缓存资源，就从缓存中返回数据\n            caches.match(e.request).then(function (response) {\n                return response || fetch(e.request);\n            })\n        );\n    }\n\n});\n")])]),e._v(" "),n("p",[n("strong",[e._v("这里进而就引入到 pwa 的推送通知功能。这都是通过 ServiceWorker 去实现的。")])]),e._v(" "),n("p",[e._v("基本原理是，你的客户端要和推送服务进行绑定，会生成一个绑定后的推送服务API接口，服务端调用此接口，发送消息。同时，浏览器也要支持推送功能，在注册 sw 时, 加上推送功能的判断。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("if ('serviceWorker' in navigator && 'PushManager' in window) {\n\tnavigator.serviceWorker.register(sw.js)\n\t.then(function(swReg) {\n        swRegistration = swReg;\n    }).catch(function(error) {\n        console.error('Service Worker Error', error);\n        });\n } else {\n     console.warn('Push messaging is not supported');\n }\n")])]),e._v(" "),n("p",[e._v("PushManager 注册好之后， 那么要做的就是浏览器和服务器的绑定了。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20171112203347222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}}),n("br"),e._v("\n此图是用户订阅某个应用程序的推送服务。"),n("br"),e._v("\n客户端传入应用程序服务器公钥，向将生成端点的 "),n("code",{pre:!0},[e._v("webpush 服务器")]),e._v("( 这是谷歌自己实现的一个推送功能的服务器)发出网络请求，将生成的端点(一个推送服务)与应用程序公钥关联，并将端点返回给应用程序。浏览器会将此端点添加到 PushSubscription，通过 promise异步成功时，可以将它的信息保存到你的数据库。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20171112203753820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFkYWRlZ2FuaHVv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"这里写图片描述"}}),n("br"),e._v("\n服务器发送推送的时候,请求相关接口，验证成功后推送服务会发消息给客户端。")]),e._v(" "),n("p",[n("strong",[e._v("最后关于桌面小图标")])]),e._v(" "),n("p",[e._v("这个可以说是非常简单了，就是一个manifest.json配置文件，然后在页面引入此文件就好了")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('\x3c!-- 加载清单 --\x3e\n<link rel="manifest" href="./manifest.json">\n')])]),e._v(" "),n("p",[e._v("关于"),n("a",{attrs:{href:"https://developers.google.com/web/fundamentals/web-app-manifest/"}},[e._v("清单内容")]),e._v("这里简单介绍一下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('{\n    "short_name": "pwa",\n    "name": "pwa - demo", // 应用名称\n    "icons": [ // 应用显示图标，根据容器大小适配\n        {\n            "src": "assets/imgs/48.png",\n            "type": "image/png",\n            "sizes": "48x48"\n        },\n        {\n            "src": "assets/imgs/96.png",\n            "type": "image/png",\n            "sizes": "96x96"\n        },\n        {\n            "src": "assets/imgs/192.png",\n            "type": "image/png",\n            "sizes": "192x192"\n        }\n    ],\n    "background_color": "#2196F3", // 刚打开页面时的背景\n    "theme_color": "#2196F3", // 主题颜色\n    "display": "standalone", //独立显示\n    "start_url": "index.html?launcher=true" // 启动的页面\n}\n')])]),e._v(" "),n("p",[e._v("好了， 如果感兴趣赶快上手吧。"),n("br"),e._v("\n可以查看"),n("a",{attrs:{href:"https://developers.google.com/web/progressive-web-apps/"}},[e._v("谷歌官方教程")]),e._v("。")]),e._v(" "),n("p",[e._v("这里说一下坑的点，\tPWA应用需要在本地localhost:8080 上运行或者 https 协议下， 要保证你的页面是安全页面。")]),e._v(" "),n("p",[e._v("添加桌面时，确保你的谷歌浏览器可以显示弹出通知。")]),e._v(" "),n("p",[e._v("如果你要自己实现推送，自己服务器要有公钥和私钥的获取， 这里可以通过 https://web-push-codelab.glitch.me 获取， 用 chrome 的 "),n("a",{attrs:{href:"https://github.com/zaru/webpush"}},[e._v("webpush")]),e._v(" 推送。")]),e._v(" "),n("p",[e._v("这里也可以看一下我的"),n("a",{attrs:{href:"https://github.com/cleverboy32/chorme-PwaDemo"}},[e._v(" GitHub 项项目 ")]),e._v("，官方也有很多例子。")])])},staticRenderFns:[]}},,function(e,t,n){e.exports=n(88)},function(e,t,n){e.exports=n(89)},function(e,t,n){e.exports=n(90)},function(e,t,n){e.exports=n(91)},function(e,t,n){e.exports=n(92)},function(e,t,n){e.exports=n(93)},function(e,t,n){e.exports=n(94)},function(e,t,n){e.exports=n(95)},function(e,t,n){e.exports=n(96)},function(e,t,n){e.exports=n(97)},function(e,t,n){e.exports=n(98)},function(e,t,n){e.exports=n(99)},function(e,t,n){e.exports=n(100)}]));
//# sourceMappingURL=0.5209f36607d516a56b7a.js.map